From 30d496f3d86831c50c0813cf7f9a3866df2fece9 Mon Sep 17 00:00:00 2001
From: Radoslav Gerganov <rgerganov@gmail.com>
Date: Thu, 18 Nov 2021 15:44:27 +0200
Subject: [PATCH] use old remote control driver

---
 drivers/amlogic/input/Makefile                |    2 +-
 drivers/amlogic/input/remote/Kconfig          |   10 +-
 drivers/amlogic/input/remote/Makefile         |    6 +-
 drivers/amlogic/input/remote/rc_common.h      |   95 -
 drivers/amlogic/input/remote/remote_cdev.c    |  303 ---
 drivers/amlogic/input/remote/remote_core.c    |  252 ---
 drivers/amlogic/input/remote/remote_core.h    |  232 ---
 .../amlogic/input/remote/remote_decoder_xmp.c |  256 ---
 drivers/amlogic/input/remote/remote_func.c    | 1778 +++++++++++++++++
 drivers/amlogic/input/remote/remote_main.c    |  983 +++++++++
 drivers/amlogic/input/remote/remote_main.h    |  668 +++++++
 drivers/amlogic/input/remote/remote_meson.c   | 1013 ----------
 drivers/amlogic/input/remote/remote_meson.h   |  228 ---
 drivers/amlogic/input/remote/remote_raw.c     |  209 --
 drivers/amlogic/input/remote/remote_regmap.c  |  716 -------
 drivers/amlogic/input/remote/sysfs.c          |  546 -----
 drivers/amlogic/input/remote/sysfs.h          |   28 -
 17 files changed, 3437 insertions(+), 3888 deletions(-)
 delete mode 100644 drivers/amlogic/input/remote/rc_common.h
 delete mode 100644 drivers/amlogic/input/remote/remote_cdev.c
 delete mode 100644 drivers/amlogic/input/remote/remote_core.c
 delete mode 100644 drivers/amlogic/input/remote/remote_core.h
 delete mode 100644 drivers/amlogic/input/remote/remote_decoder_xmp.c
 create mode 100644 drivers/amlogic/input/remote/remote_func.c
 create mode 100644 drivers/amlogic/input/remote/remote_main.c
 create mode 100644 drivers/amlogic/input/remote/remote_main.h
 delete mode 100644 drivers/amlogic/input/remote/remote_meson.c
 delete mode 100644 drivers/amlogic/input/remote/remote_meson.h
 delete mode 100644 drivers/amlogic/input/remote/remote_raw.c
 delete mode 100644 drivers/amlogic/input/remote/remote_regmap.c
 delete mode 100644 drivers/amlogic/input/remote/sysfs.c
 delete mode 100644 drivers/amlogic/input/remote/sysfs.h

diff --git a/drivers/amlogic/input/Makefile b/drivers/amlogic/input/Makefile
index 3ea361c82a53..6f6dff05bff0 100644
--- a/drivers/amlogic/input/Makefile
+++ b/drivers/amlogic/input/Makefile
@@ -8,7 +8,7 @@ obj-$(CONFIG_AMLOGIC_AVIN_DETECT) += avin_detect/
 
 obj-$(CONFIG_AMLOGIC_INPUT_KEYBOARD) += keyboard/
 
-obj-$(CONFIG_AMLOGIC_REMOTE) += remote/
+obj-$(CONFIG_MESON_NEW_INPUT_REMOTE) += remote/
 
 obj-$(CONFIG_AMLOGIC_TOUCHSCREEN) += touchscreen/
 
diff --git a/drivers/amlogic/input/remote/Kconfig b/drivers/amlogic/input/remote/Kconfig
index 7dd8b10dba46..84e82415ed17 100644
--- a/drivers/amlogic/input/remote/Kconfig
+++ b/drivers/amlogic/input/remote/Kconfig
@@ -1,18 +1,18 @@
 #
 # Remote control drivers
 #
-menuconfig AMLOGIC_REMOTE
+menuconfig MESON_NEW_INPUT_REMOTE
 	bool "GX Remotes"
-	default n
+	default y
 	help
 	  Say Y here, and a list of supported remote controls will be displayed.
 	  This option doesn't affect the kernel.
 
 	  If unsure, say Y.
 
-if AMLOGIC_REMOTE
+if MESON_NEW_INPUT_REMOTE
 
-config AMLOGIC_MESON_REMOTE
+config NEW_AM_REMOTE
 	tristate "GX IR remote control support"
 	default n
 	help
@@ -20,4 +20,4 @@ config AMLOGIC_MESON_REMOTE
 
 
 
-endif # AMLOGIC_REMOTE
+endif # MESON_INPUT_REMOTE
diff --git a/drivers/amlogic/input/remote/Makefile b/drivers/amlogic/input/remote/Makefile
index 81e95f55cb7b..e657f8357fb0 100644
--- a/drivers/amlogic/input/remote/Makefile
+++ b/drivers/amlogic/input/remote/Makefile
@@ -4,7 +4,5 @@
 
 # Each configuration option enables a list of files.
 
-obj-$(CONFIG_IR_XMP_DECODER)			+= remote_decoder_xmp.o
-obj-$(CONFIG_AMLOGIC_MESON_REMOTE)		+= meson-remote.o
-
-meson-remote-objs := remote_core.o remote_meson.o sysfs.o remote_cdev.o remote_raw.o remote_regmap.o
+obj-$(CONFIG_NEW_AM_REMOTE)		+= remote.o
+remote-objs := remote_main.o remote_func.o
diff --git a/drivers/amlogic/input/remote/rc_common.h b/drivers/amlogic/input/remote/rc_common.h
deleted file mode 100644
index fdc6b8f09d0a..000000000000
--- a/drivers/amlogic/input/remote/rc_common.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * drivers/amlogic/input/remote/rc_common.h
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#ifndef _UAPI_RC_COMMON_H_
-#define _UAPI_RC_COMMON_H_
-
-#include <linux/types.h>
-
-#define MAX_KEYMAP_SIZE 256
-#define CUSTOM_NAME_LEN 64
-
-/*to ensure kernel and user spase use the same header file*/
-#define SHARE_DATA_VERSION "v1.1.0"
-
-union _codemap {
-	struct ir_key_map {
-		__u16 keycode;
-		__u16 scancode;
-		} map;
-	__u32 code;
-};
-
-/*
- *struct cursor_codemap - codemap for mouse mode
- *
- *@fn_key_scancode: scancode of fn key which used to swith mode
- *@cursor_left_scancode: scancode of left key
- *@cursor_right_scancode: scancode of right key
- *@cursor_up_scancode: scancode of up key
- *@cursor_down_scancode: scancode of down key
- *@cursor_ok_scancode: scancode of ok key
- */
-struct cursor_codemap {
-	__u16 fn_key_scancode;
-	__u16 cursor_left_scancode;
-	__u16 cursor_right_scancode;
-	__u16 cursor_up_scancode;
-	__u16 cursor_down_scancode;
-	__u16 cursor_ok_scancode;
-};
-
-/**
- *struct ir_map_table - the IR key map table for different remote-control
- *
- *@custom_name: table name
- *@cursor_code: mouse mode need
- *@map_size: number of IR key
- *@custom_code: custom code, identify different key mapping table
- *@release_delay: release delay time
- *@codemap[0]: code for IR key
- */
-struct ir_map_tab {
-	char custom_name[CUSTOM_NAME_LEN];
-	struct cursor_codemap cursor_code;
-	__u16 map_size;
-	__u32 custom_code;
-	__u32 release_delay;
-	union _codemap codemap[0];
-};
-
-/**
- *struct ir_sw_decode_para - configuration parameters for software decode
- *
- *@max_frame_time: maximum frame time
- */
-struct ir_sw_decode_para {
-	unsigned int  max_frame_time;
-};
-
-/*IOCTL commands*/
-#define REMOTE_IOC_SET_KEY_NUMBER        _IOW('I', 3, __u32)
-#define REMOTE_IOC_SET_KEY_MAPPING_TAB   _IOW('I', 4, __u32)
-#define REMOTE_IOC_SET_SW_DECODE_PARA    _IOW('I', 5, __u32)
-#define REMOTE_IOC_GET_DATA_VERSION      _IOR('I', 121, __u32)
-#define REMOTE_IOC_SET_IR_LEARNING       _IOW('I', 6, __u32)
-#define REMOTE_IOC_GET_IR_LEARNING       _IOR('I', 7, __u32)
-#define REMOTE_IOC_GET_RAW_DATA          _IOR('I', 8, __u32)
-#define REMOTE_IOC_GET_SUM_CNT0          _IOR('I', 9, __u32)
-#define REMOTE_IOC_GET_SUM_CNT1          _IOR('I', 10, __u32)
-
-#endif
diff --git a/drivers/amlogic/input/remote/remote_cdev.c b/drivers/amlogic/input/remote/remote_cdev.c
deleted file mode 100644
index 564fdb16b5a8..000000000000
--- a/drivers/amlogic/input/remote/remote_cdev.c
+++ /dev/null
@@ -1,303 +0,0 @@
-/*
- * drivers/amlogic/input/remote/remote_cdev.c
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/uaccess.h>
-#include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/fs.h>
-#include <linux/interrupt.h>
-#include "remote_meson.h"
-#include "sysfs.h"
-
-#define AML_REMOTE_NAME "amremote"
-
-static int remote_open(struct inode *inode, struct file *file)
-{
-	struct remote_chip *chip;
-
-	chip = container_of(inode->i_cdev, struct remote_chip, chrdev);
-	file->private_data = chip;
-	disable_irq(chip->irqno);
-	return 0;
-}
-static long remote_ioctl(struct file *file, unsigned int cmd,
-				unsigned long arg)
-{
-	struct remote_chip *chip = (struct remote_chip *)file->private_data;
-	struct ir_sw_decode_para sw_data;
-	struct ir_map_tab_list *ir_map;
-	struct ir_map_tab_list *ptable;
-	void __user *parg = (void __user *)arg;
-	unsigned long flags;
-	u32 value;
-	u8 val;
-	int retval = 0;
-
-	if (!parg) {
-		dev_err(chip->dev, "%s invalid user space pointer\n", __func__);
-		return -EINVAL;
-	}
-
-	mutex_lock(&chip->file_lock);
-	switch (cmd) {
-	case REMOTE_IOC_GET_DATA_VERSION:
-		if (copy_to_user(parg, SHARE_DATA_VERSION,
-						sizeof(SHARE_DATA_VERSION))) {
-			retval = -EFAULT;
-			goto err;
-		}
-	break;
-
-	case REMOTE_IOC_SET_KEY_NUMBER:
-		if (copy_from_user(&value, parg, sizeof(u32))) {
-			chip->key_num.update_flag = false;
-			retval = -EFAULT;
-			goto err;
-		}
-
-		if (value < 1 || value > MAX_KEYMAP_SIZE) {
-			chip->key_num.update_flag = false;
-			retval = -EINVAL;
-			goto err;
-		}
-
-		chip->key_num.update_flag = true;
-		chip->key_num.value = value;
-		break;
-
-	case REMOTE_IOC_SET_KEY_MAPPING_TAB:
-		if (chip->key_num.update_flag) {
-			ir_map = kzalloc(sizeof(struct ir_map_tab_list) +
-				chip->key_num.value * sizeof(union _codemap),
-			    GFP_KERNEL);
-			if (!ir_map) {
-				dev_err(chip->dev, "%s ir map table alloc err\n",
-						__func__);
-				retval = -ENOMEM;
-				goto err;
-			}
-			if (copy_from_user(&ir_map->tab, parg,
-				sizeof(struct ir_map_tab) +
-				chip->key_num.value * sizeof(union _codemap))) {
-				ir_tab_free(ir_map);
-				retval = -EFAULT;
-				goto err;
-			}
-
-			/* Check data whether valid or not*/
-			if (chip->key_num.value != ir_map->tab.map_size) {
-				ir_tab_free(ir_map);
-				retval = -EFAULT;
-				goto err;
-			}
-			/*scancode sort*/
-			ir_scancode_sort(&ir_map->tab);
-
-			/*overwrite the old map table or insert new map table*/
-			spin_lock_irqsave(&chip->slock, flags);
-			ptable = seek_map_tab(chip, ir_map->tab.custom_code);
-			if (ptable) {
-				dev_info(chip->dev, "remove custom_code 0x%08X from ir map table\n",
-					ir_map->tab.custom_code);
-				if (ptable == chip->cur_tab)
-					chip->cur_tab = ir_map;
-				list_del(&ptable->list);
-				ir_tab_free(ptable);
-			}
-			dev_info(chip->dev, "add custom_code 0x%08X to ir map table\n",
-				ir_map->tab.custom_code);
-			list_add_tail(&ir_map->list, &chip->map_tab_head);
-			spin_unlock_irqrestore(&chip->slock, flags);
-			chip->key_num.update_flag = false;
-		}
-		break;
-
-	case REMOTE_IOC_SET_SW_DECODE_PARA:
-		if (copy_from_user(&sw_data, parg,
-				sizeof(struct ir_sw_decode_para))) {
-			retval = -EFAULT;
-			goto err;
-		}
-		chip->r_dev->max_frame_time = sw_data.max_frame_time;
-		break;
-	case REMOTE_IOC_GET_IR_LEARNING:
-		if (copy_to_user(parg, &chip->r_dev->ir_learning_on,
-				 sizeof(u8))) {
-			retval = -EFAULT;
-			goto err;
-		}
-		break;
-
-	case REMOTE_IOC_SET_IR_LEARNING:
-		/*reset demudolation and carrier detect*/
-		if (chip->r_dev->demod_enable)
-			demod_reset(chip);
-
-		if (copy_from_user(&val, parg, sizeof(u8))) {
-			retval = -EFAULT;
-			goto err;
-		}
-
-		chip->r_dev->ir_learning_on = !!val;
-		if (!!val) {
-			if (remote_pulses_malloc(chip) < 0) {
-				retval = -ENOMEM;
-				goto err;
-			}
-			chip->set_register_config(chip, REMOTE_TYPE_RAW_NEC);
-			/*backup protocol*/
-			chip->r_dev->protocol = chip->protocol;
-			chip->protocol = REMOTE_TYPE_RAW_NEC;
-			irq_set_affinity_hint(chip->irqno,
-					 cpumask_of(chip->irq_cpumask));
-		} else {
-			chip->protocol = chip->r_dev->protocol;
-			chip->set_register_config(chip, chip->protocol);
-			remote_pulses_free(chip);
-			chip->r_dev->ir_learning_done = false;
-		}
-		break;
-
-	case REMOTE_IOC_GET_RAW_DATA:
-		if (copy_to_user(parg, chip->r_dev->pulses,
-			sizeof(struct pulse_group) +
-			chip->r_dev->max_learned_pulse *
-			sizeof(unsigned int))) {
-			retval = -EFAULT;
-			goto err;
-		}
-		/*clear to prepear next frame*/
-		memset(chip->r_dev->pulses, 0, sizeof(struct pulse_group) +
-			chip->r_dev->max_learned_pulse *
-			sizeof(unsigned int));
-
-		if (chip->r_dev->demod_enable)
-			demod_reset(chip);
-
-		/*finish reading data ,enable state machine */
-		remote_reg_update_bits(chip, MULTI_IR_ID, REG_REG1, BIT(15),
-				       BIT(15));
-
-		chip->r_dev->ir_learning_done = false;
-
-		break;
-
-	case REMOTE_IOC_GET_SUM_CNT0:
-		if (chip->r_dev->demod_enable) {
-			remote_reg_read(chip, MULTI_IR_ID, REG_DEMOD_SUM_CNT0,
-					&value);
-			if (copy_to_user(parg, &value, sizeof(u32))) {
-				retval = -EFAULT;
-				goto err;
-			}
-		} else {
-			retval = -EFAULT;
-			goto err;
-		}
-		break;
-
-	case REMOTE_IOC_GET_SUM_CNT1:
-		if (chip->r_dev->demod_enable) {
-			remote_reg_read(chip, MULTI_IR_ID, REG_DEMOD_SUM_CNT1,
-					&value);
-			if (copy_to_user(parg, &value, sizeof(u32))) {
-				retval = -EFAULT;
-				goto err;
-			}
-		} else {
-			retval = -EFAULT;
-			goto err;
-		}
-		break;
-
-	default:
-		retval = -ENOTTY;
-		goto err;
-	}
-err:
-	mutex_unlock(&chip->file_lock);
-	return retval;
-}
-static int remote_release(struct inode *inode, struct file *file)
-{
-	struct remote_chip *chip = (struct remote_chip *)file->private_data;
-
-	enable_irq(chip->irqno);
-	file->private_data = NULL;
-	return 0;
-}
-
-static const struct file_operations remote_fops = {
-	.owner = THIS_MODULE,
-	.open = remote_open,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl = remote_ioctl,
-#endif
-	.unlocked_ioctl = remote_ioctl,
-	.release = remote_release,
-};
-
-int ir_cdev_init(struct remote_chip *chip)
-{
-	int ret = 0;
-
-	chip->dev_name  = AML_REMOTE_NAME;
-	ret = alloc_chrdev_region(&chip->chr_devno,
-		0, 1, AML_REMOTE_NAME);
-	if (ret < 0) {
-		dev_err(chip->dev, "failed to allocate major number\n");
-		ret = -ENODEV;
-		goto err_end;
-	}
-	cdev_init(&chip->chrdev, &remote_fops);
-	chip->chrdev.owner = THIS_MODULE;
-	ret = cdev_add(&chip->chrdev, chip->chr_devno, 1);
-	if (ret < 0) {
-		dev_err(chip->dev, "failed to cdev_add\n");
-		goto err_cdev_add;
-	}
-
-	ret = ir_sys_device_attribute_init(chip);
-	if (ret < 0) {
-		dev_err(chip->dev, "failed to ir_sys create %d\n", ret);
-		goto err_ir_sys;
-	}
-	return 0;
-
-err_ir_sys:
-	dev_err(chip->dev, "err_ir_sys\n");
-	cdev_del(&chip->chrdev);
-err_cdev_add:
-	dev_err(chip->dev, "err_cdev_add\n");
-	unregister_chrdev_region(chip->chr_devno, 1);
-err_end:
-	return ret;
-}
-EXPORT_SYMBOL(ir_cdev_init);
-
-void ir_cdev_free(struct remote_chip *chip)
-{
-	ir_sys_device_attribute_sys(chip);
-	cdev_del(&chip->chrdev);
-	unregister_chrdev_region(chip->chr_devno, 1);
-}
-EXPORT_SYMBOL(ir_cdev_free);
-
diff --git a/drivers/amlogic/input/remote/remote_core.c b/drivers/amlogic/input/remote/remote_core.c
deleted file mode 100644
index f59c8c72aef5..000000000000
--- a/drivers/amlogic/input/remote/remote_core.c
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * drivers/amlogic/input/remote/remote_core.c
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/types.h>
-#include <linux/input.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/errno.h>
-#include <asm/irq.h>
-#include <linux/io.h>
-
-/*#include <mach/pinmux.h>*/
-#include <linux/major.h>
-#include <linux/slab.h>
-#include <linux/uaccess.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/of_platform.h>
-#include <linux/amlogic/cpu_version.h>
-#include <linux/of_address.h>
-#include "remote_core.h"
-
-/**
- *global variable for debug
- *disable: 0
- *enable: 1
- */
-static bool remote_debug_enable;
-
-void remote_repeat(struct remote_dev *dev)
-{
-
-}
-
-void remote_debug_set_enable(bool enable)
-{
-	remote_debug_enable = enable;
-}
-
-bool remote_debug_get_enable(void)
-{
-	return remote_debug_enable;
-}
-
-static void ir_do_keyup(struct remote_dev *dev)
-{
-	input_report_key(dev->input_device, dev->last_keycode, 0);
-	input_sync(dev->input_device);
-	if (dev->last_keycode == KEY_POWER)
-		pm_relax(dev->dev);
-	dev->keypressed = false;
-	dev->last_scancode = -1;
-	remote_dbg(dev->dev, "keyup!!\n");
-}
-
-static void ir_timer_keyup(unsigned long cookie)
-{
-	struct remote_dev *dev = (struct remote_dev *)cookie;
-	unsigned long flags;
-
-	if (!dev->keypressed)
-		return;
-	spin_lock_irqsave(&dev->keylock, flags);
-	if (dev->is_next_repeat(dev)) {
-		dev->keyup_jiffies = jiffies +
-			msecs_to_jiffies(dev->keyup_delay);
-		mod_timer(&dev->timer_keyup, dev->keyup_jiffies);
-		dev->wait_next_repeat = 1;
-		remote_dbg(dev->dev, "wait for repeat\n");
-	} else {
-		if (time_is_before_eq_jiffies(dev->keyup_jiffies))
-			ir_do_keyup(dev);
-		dev->wait_next_repeat = 0;
-	}
-	spin_unlock_irqrestore(&dev->keylock, flags);
-}
-
-static void ir_do_keydown(struct remote_dev *dev, int scancode,
-			  u32 keycode)
-{
-	remote_dbg(dev->dev, "keypressed=0x%x\n", dev->keypressed);
-
-	if (dev->keypressed)
-		ir_do_keyup(dev);
-
-	if (keycode != KEY_RESERVED) {
-		dev->keypressed = true;
-		dev->last_scancode = scancode;
-		dev->last_keycode = keycode;
-		input_report_key(dev->input_device, keycode, 1);
-		input_sync(dev->input_device);
-		remote_dbg(dev->dev, "report key!!\n");
-	} else {
-		dev_err(dev->dev, "no valid key to handle");
-	}
-}
-
-void remote_keydown(struct remote_dev *dev, int scancode, int status)
-{
-	unsigned long flags;
-	u32 keycode;
-
-	if (dev->led_blink)
-		led_trigger_blink_oneshot(dev->led_feedback, &dev->delay_on,
-			 &dev->delay_off, 0);
-
-	if (status != REMOTE_REPEAT) {
-		if (dev->is_valid_custom &&
-			(false == dev->is_valid_custom(dev)))
-			dev_err(dev->dev, "invalid custom:0x%x\n",
-				dev->cur_hardcode);
-	}
-	spin_lock_irqsave(&dev->keylock, flags);
-	/**
-	 *only a few keys which be set in key map table support
-	 *report relative axes event in mouse mode, other keys
-	 *will continue to report key event.
-	 */
-	if (status == REMOTE_NORMAL ||
-			status == REMOTE_REPEAT) {
-		/*to report relative axes event*/
-		if (dev->ir_report_rel(dev, scancode, status) == 0) {
-			spin_unlock_irqrestore(&dev->keylock, flags);
-			return;
-		}
-	}
-
-	if (status == REMOTE_NORMAL) {
-		keycode = dev->getkeycode(dev, scancode);
-		if (keycode == KEY_POWER)
-			pm_stay_awake(dev->dev);
-		ir_do_keydown(dev, scancode, keycode);
-	}
-
-	if (dev->keypressed) {
-		dev->wait_next_repeat = 0;
-		dev->keyup_jiffies = jiffies +
-			msecs_to_jiffies(dev->keyup_delay);
-		mod_timer(&dev->timer_keyup, dev->keyup_jiffies);
-	}
-	spin_unlock_irqrestore(&dev->keylock, flags);
-}
-EXPORT_SYMBOL(remote_keydown);
-
-struct remote_dev *remote_allocate_device(void)
-{
-	struct remote_dev *dev;
-
-	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev)
-		return NULL;
-
-	dev->input_device = input_allocate_device();
-	if (!dev->input_device) {
-		kfree(dev);
-		return NULL;
-	}
-	input_set_drvdata(dev->input_device, dev);
-
-	setup_timer(&dev->timer_keyup, ir_timer_keyup, (unsigned long)dev);
-
-	spin_lock_init(&dev->keylock);
-
-	dev->wait_next_repeat = 0;
-	return dev;
-}
-EXPORT_SYMBOL(remote_allocate_device);
-
-void remote_free_device(struct remote_dev *dev)
-{
-	input_free_device(dev->input_device);
-	kfree(dev);
-}
-EXPORT_SYMBOL(remote_free_device);
-
-
-int remote_register_device(struct remote_dev *dev)
-{
-	int i;
-	int ret;
-
-	if (MULTI_IR_SOFTWARE_DECODE(dev->rc_type)) {
-		remote_raw_init();
-		remote_raw_event_register(dev);
-	}
-
-	__set_bit(EV_KEY, dev->input_device->evbit);
-	for (i = KEY_RESERVED; i < BTN_MISC; i++)
-		__set_bit(i, dev->input_device->keybit);
-	for (i = KEY_OK; i < BTN_TRIGGER_HAPPY; i++)
-		__set_bit(i, dev->input_device->keybit);
-
-	__set_bit(BTN_MOUSE, dev->input_device->keybit);
-	__set_bit(BTN_LEFT, dev->input_device->keybit);
-	__set_bit(BTN_RIGHT, dev->input_device->keybit);
-	__set_bit(BTN_MIDDLE, dev->input_device->keybit);
-
-	__set_bit(EV_REL, dev->input_device->evbit);
-	__set_bit(REL_X, dev->input_device->relbit);
-	__set_bit(REL_Y, dev->input_device->relbit);
-	__set_bit(REL_WHEEL, dev->input_device->relbit);
-
-	dev->input_device->keycodesize = sizeof(unsigned short);
-	dev->input_device->keycodemax = 0x1ff;
-
-	ret = input_register_device(dev->input_device);
-
-	dev->debug_current     = 0;
-	dev->debug_buffer_size = 4096;
-	dev->debug_buffer = kzalloc(dev->debug_buffer_size, GFP_KERNEL);
-	if (!dev->debug_buffer) {
-		dev_err(dev->dev, "kzalloc debug_buffer error!\n");
-		ret = -ENOMEM;
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL(remote_register_device);
-
-
-void remote_unregister_device(struct remote_dev *dev)
-{
-	if (MULTI_IR_SOFTWARE_DECODE(dev->rc_type))
-		remote_raw_event_unregister(dev);
-
-	input_unregister_device(dev->input_device);
-	kfree(dev->debug_buffer);
-}
-EXPORT_SYMBOL(remote_unregister_device);
-
-MODULE_AUTHOR("AMLOGIC");
-MODULE_DESCRIPTION("Remote Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/input/remote/remote_core.h b/drivers/amlogic/input/remote/remote_core.h
deleted file mode 100644
index b0f72517c271..000000000000
--- a/drivers/amlogic/input/remote/remote_core.h
+++ /dev/null
@@ -1,232 +0,0 @@
-/*
- * drivers/amlogic/input/remote/remote_core.h
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#ifndef _REMOTE_MAIN_MY_H
-#define _REMOTE_MAIN_MY_H
-
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-#include <linux/kfifo.h>
-#include <linux/device.h>
-#include <dt-bindings/input/meson_rc.h>
-#include <linux/leds.h>
-
-#define MULTI_IR_TYPE_MASK(type) (type & 0xff)  /*8bit*/
-#define LEGACY_IR_TYPE_MASK(type) ((type >> 8) & 0xff) /*8bit*/
-/*bit[7] identify whether software decode or not*/
-#define MULTI_IR_SOFTWARE_DECODE(type) ((MULTI_IR_TYPE_MASK(type) >> 7) == 0x1)
-#define ENABLE_LEGACY_IR(type) (LEGACY_IR_TYPE_MASK(type) == 0xff)
-
-#define remote_dbg(dev, format, arg...)     \
-do {                                        \
-	if (remote_debug_get_enable()) {        \
-		if (likely(dev))                    \
-			dev_info(dev, format, ##arg);   \
-		else                                \
-			pr_info(format, ##arg);         \
-	}                                       \
-} while (0)
-
-enum remote_status {
-	REMOTE_NORMAL = 0x00,
-	REMOTE_REPEAT = 1<<0,
-	REMOTE_CUSTOM_ERROR = 1<<1,
-	REMOTE_DATA_ERROR = 1<<2,
-	REMOTE_FRAME_ERROR = 1<<3,
-	REMOTE_CHECKSUM_ERROR = 1<<4,
-	REMOTE_CUSTOM_DATA    = 1<<5
-};
-
-enum raw_event_type {
-	RAW_SPACE        = (1 << 0),
-	RAW_PULSE        = (1 << 1),
-	RAW_START_EVENT  = (1 << 2),
-	RAW_STOP_EVENT   = (1 << 3),
-};
-
-struct pulse_group {
-	int len;
-	/*bit 0-30 durations, bit31: level*/
-	unsigned int pulse[0];
-};
-
-struct remote_raw_handle;
-struct remote_dev {
-	struct device *dev;
-	struct input_dev *input_device;
-	struct list_head reg_list;
-	struct list_head aml_list;
-	struct remote_raw_handle *raw;
-	spinlock_t keylock;
-
-#define DEFAULT_LED_BLINK_FRQ	100
-	struct led_trigger *led_feedback;
-	unsigned long delay_on;
-	unsigned long delay_off;
-	int led_blink;
-
-	/*for ir learnning feature*/
-#define MAX_LEARNED_PULSE	256
-	/*ir learnning switch*/
-	u8 ir_learning_on;
-	u8 ir_learning_done;
-	u8 demod_enable;
-	u8 use_fifo;
-	u8 auto_report;
-	int max_learned_pulse;
-	int protocol;
-	struct timer_list learning_done;
-	struct pulse_group *pulses;
-
-	struct timer_list timer_keyup;
-	unsigned long keyup_jiffies;
-	unsigned long keyup_delay;
-	bool keypressed;
-
-	u32 last_scancode;
-	u32 last_keycode;
-	int rc_type;
-	u32 cur_hardcode;
-	u32 cur_customcode;
-	u32 repeat_time;
-	u32 max_frame_time;
-	int wait_next_repeat;
-	void *platform_data;
-
-	/*debug*/
-	char *debug_buffer;
-	int debug_buffer_size;
-	int debug_current;
-
-	u32 (*getkeycode)(struct remote_dev *, u32);
-	int (*ir_report_rel)(struct remote_dev *, u32, int);
-	bool (*set_custom_code)(struct remote_dev *, u32);
-	bool (*is_valid_custom)(struct remote_dev *);
-	bool (*is_next_repeat)(struct remote_dev *);
-};
-
-struct remote_raw_handle {
-	struct list_head list;
-	struct remote_dev *dev;
-	struct task_struct *thread;
-	struct kfifo_rec_ptr_1 kfifo;/* fifo for the pulse/space durations */
-	spinlock_t lock;
-
-	enum raw_event_type last_type;
-	unsigned long jiffies_old;
-	unsigned long repeat_time;
-	unsigned long max_frame_time;
-};
-
-struct remote_map_table {
-	u32 scancode;
-	u32 keycode;
-};
-
-struct remote_map {
-	struct remote_map_table *scan;
-	int rc_type;
-	const char *name;
-	u32 size;
-};
-
-struct remote_map_list {
-	struct list_head     list;
-	struct remote_map    map;
-};
-
-enum {
-	SCAN_CODE_REPEAT,
-	SCAN_CODE_NORMAL
-};
-
-struct remote_raw_event {
-	u32             duration;
-	unsigned        pulse:1;
-	unsigned        reset:1;
-	unsigned        timeout:1;
-};
-
-#define DEFINE_REMOTE_RAW_EVENT(event) \
-	struct remote_raw_event event = { \
-		.duration = 0, \
-		.pulse = 0, \
-		.reset = 0, \
-		.timeout = 0}
-
-
-
-struct remote_raw_handler {
-	struct list_head list;
-
-	int protocols;
-	void *data;
-	int (*decode)(struct remote_dev *dev, struct remote_raw_event event,
-		void *data_dec);
-};
-
-
-/* macros for IR decoders */
-static inline bool geq_margin(unsigned int d1, unsigned int d2,
-						unsigned int margin)
-{
-	return d1 > (d2 - margin);
-}
-
-static inline bool eq_margin(unsigned int d1, unsigned int d2,
-						unsigned int margin)
-{
-	return (d1 > (d2 - margin)) && (d1 < (d2 + margin));
-}
-
-static inline bool is_transition(struct remote_raw_event *x,
-	struct remote_raw_event *y)
-{
-	return x->pulse != y->pulse;
-}
-
-static inline void decrease_duration(struct remote_raw_event *ev,
-		unsigned int duration)
-{
-	if (duration > ev->duration)
-		ev->duration = 0;
-	else
-		ev->duration -= duration;
-}
-
-int remote_register_device(struct remote_dev *dev);
-void remote_free_device(struct remote_dev *dev);
-void remote_unregister_device(struct remote_dev *dev);
-struct remote_dev *remote_allocate_device(void);
-void remote_keydown(struct remote_dev *dev, int scancode, int status);
-
-int remote_raw_event_store(struct remote_dev *dev, struct remote_raw_event *ev);
-int remote_raw_event_register(struct remote_dev *dev);
-void remote_raw_event_unregister(struct remote_dev *dev);
-int remote_raw_handler_register(struct remote_raw_handler *handler);
-void remote_raw_handler_unregister(struct remote_raw_handler *handler);
-void remote_raw_event_handle(struct remote_dev *dev);
-int remote_raw_event_store_edge(struct remote_dev *dev,
-	enum raw_event_type type, u32 duration);
-void remote_raw_init(void);
-
-/*debug printk */
-void remote_debug_set_enable(bool enable);
-bool remote_debug_get_enable(void);
-int debug_log_printk(struct remote_dev *dev, const char *fmt);
-
-#endif
diff --git a/drivers/amlogic/input/remote/remote_decoder_xmp.c b/drivers/amlogic/input/remote/remote_decoder_xmp.c
deleted file mode 100644
index 6698615ea1a4..000000000000
--- a/drivers/amlogic/input/remote/remote_decoder_xmp.c
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- * drivers/amlogic/input/remote/remote_decoder_xmp.c
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#include <linux/bitrev.h>
-#include <linux/module.h>
-#include "remote_meson.h"
-
-#define XMP_UNIT		  136000 /* ns */
-#define XMP_LEADER		  210000 /* ns */
-#define XMP_NIBBLE_PREFIX	  760000 /* ns */
-#define	XMP_HALFFRAME_SPACE	13800000 /* ns */
-
-/* should be 80ms but not all dureation supliers can go that high */
-#define	XMP_TRAILER_SPACE	20000000
-
-enum xmp_state {
-	STATE_INACTIVE,
-	STATE_LEADER_PULSE,
-	STATE_NIBBLE_SPACE,
-};
-
-struct nibble_win {
-	u8 value;
-	int min;
-	int max;
-};
-
-struct xmp_dec {
-	int state;
-	unsigned int count;
-	u32 durations[16];
-};
-
-static const struct nibble_win nibble_windows[] = {
-	{0, 690000, 826000},   /*758000*/
-	{1, 827000, 963000},   /*895000*/
-	{2, 964000, 1100000},   /*1032000*/
-	{3, 1110000, 1237000},   /*1169000*/
-	{4, 1238000, 1374000},   /*1306000*/
-	{5, 1375000, 1511000},   /*1443000*/
-	{6, 1512000, 1648000},   /*1580000*/
-	{7, 1649000, 1785000},   /*1717000*/
-	{8, 1786000, 1922000},   /*1854000*/
-	{9, 1923000, 2059000},   /*1991000*/
-	{0xa, 2060000, 2196000}, /*2128000*/
-	{0xb, 2197000, 2333000}, /*2265000*/
-	{0xc, 2334000, 2470000}, /*2402000*/
-	{0xd, 2471000, 2607000}, /*2539000*/
-	{0xe, 2608000, 2744000}, /*2676000*/
-	{0x0f, 2745000, 2881000}, /*2813000*/
-	{0xff, 11800000, 16800000} /*13800000 ,half frame space*/
-};
-
-int decode_xmp(struct remote_dev *dev,
-	struct xmp_dec *data, struct remote_raw_event *ev)
-{
-	int  i;
-	u8 addr, subaddr, subaddr2, toggle, oem, obc1, obc2, sum1, sum2;
-	u32 *n;
-	u32 scancode;
-	int custom_code;
-	int nb = 0;
-	char buf[512];
-
-	if (data->count != 16) {
-		sprintf(buf, "rx TRAILER c=%d, d=%d\n",
-			data->count, ev->duration);
-		debug_log_printk(dev, buf);
-		data->state = STATE_INACTIVE;
-		return -EINVAL;
-	}
-
-	n = data->durations;
-	for (i = 0; i < 16; i++) {
-		for (nb = 0; nb < 16; nb++) {
-			if (n[i] >= nibble_windows[nb].min &&
-				n[i] <= nibble_windows[nb].max) {
-				n[i] = nibble_windows[nb].value;
-			}
-		}
-	}
-	sum1 = (15 + n[0] + n[1] + n[2] + n[3] +
-		n[4] + n[5] + n[6] + n[7]) % 16;
-	sum2 = (15 + n[8] + n[9] + n[10] + n[11] +
-		n[12] + n[13] + n[14] + n[15]) % 16;
-
-	if (sum1 != 15 || sum2 != 15) {
-		debug_log_printk(dev, "checksum err\n");
-		data->state = STATE_INACTIVE;
-		return -EINVAL;
-	}
-
-	subaddr	= n[0] << 4 | n[2];
-	subaddr2 = n[8] << 4 | n[11];
-	oem = n[4] << 4 | n[5];
-	addr = n[6] << 4 | n[7];
-	toggle = n[10];
-	obc1 = n[12] << 4 | n[13];
-	obc2 = n[14] << 4 | n[15];
-
-	if (subaddr != subaddr2) {
-		sprintf(buf, "s1!=s2\n");
-		debug_log_printk(dev, buf);
-		data->state = STATE_INACTIVE;
-		return -EINVAL;
-	}
-	scancode = obc1;
-	custom_code =  oem << 8 | addr;
-	sprintf(buf, "custom_code=%d\n", custom_code);
-	debug_log_printk(dev, buf);
-	sprintf(buf, "scancode=0x%x,t=%d\n", scancode, toggle);
-	debug_log_printk(dev, buf);
-	dev->set_custom_code(dev, custom_code);
-	if (toggle == 0)
-		remote_keydown(dev, scancode, REMOTE_NORMAL);
-	else
-		remote_keydown(dev, scancode, REMOTE_REPEAT);
-
-	data->state = STATE_INACTIVE;
-	return 0;
-}
-
-/**
- * ir_xmp_decode() - Decode one XMP pulse or space
- * @dev:	the struct rc_dev descriptor of the device
- * @duration:	the struct ir_raw_event descriptor of the pulse/space
- *
- * This function returns -EINVAL if the pulse violates the state machine
- */
-static int ir_xmp_decode(struct remote_dev *dev, struct remote_raw_event ev,
-				void *data_dec)
-{
-	struct xmp_dec *data = data_dec;
-	char buf[512];
-
-	if (ev.reset) {
-		data->state = STATE_INACTIVE;
-		return 0;
-	}
-
-	sprintf(buf, "dr:%d,s=%d, c=%d\n",
-		ev.duration, data->state, data->count);
-	debug_log_printk(dev, buf);
-
-	switch (data->state) {
-
-	case STATE_INACTIVE:
-		if (eq_margin(ev.duration, XMP_LEADER, XMP_UNIT / 2)) {
-			data->count = 0;
-			data->state = STATE_NIBBLE_SPACE;
-		}
-
-		return 0;
-
-	case STATE_LEADER_PULSE:
-		debug_log_printk(dev, "STATE_LEADER_PULSE\n");
-
-		if (eq_margin(ev.duration, XMP_LEADER, XMP_UNIT / 2))
-			data->state = STATE_NIBBLE_SPACE;
-
-		if (data->count == 16)
-			return decode_xmp(dev, data, &ev);
-		return 0;
-
-	case STATE_NIBBLE_SPACE:
-		if (geq_margin(ev.duration,
-			XMP_TRAILER_SPACE, XMP_NIBBLE_PREFIX)) {
-			return decode_xmp(dev, data, &ev);
-		} else if (geq_margin(ev.duration, XMP_HALFFRAME_SPACE,
-							XMP_NIBBLE_PREFIX)) {
-			/* Expect 8 or 16 nibble pulses. 16
-			 * in case of 'final' frame
-			 */
-			if (data->count == 16) {
-				/*
-				 * TODO: for now go back to half frame position
-				 *	 so trailer can be found and key press
-				 *	 can be handled.
-				 */
-				debug_log_printk(dev, "over pulses\n");
-				data->count = 8;
-			} else if (data->count != 8)
-				debug_log_printk(dev, "half frame\n");
-			data->state = STATE_LEADER_PULSE;
-			return 0;
-
-		} else if (geq_margin(ev.duration,
-			XMP_NIBBLE_PREFIX, XMP_UNIT)) {
-			/* store nibble raw data, decode after trailer */
-			if (data->count == 16) {
-				debug_log_printk(dev, "over pulses\n");
-				data->state = STATE_INACTIVE;
-				return -EINVAL;
-			}
-			data->durations[data->count] = ev.duration;
-			data->count++;
-			data->state = STATE_LEADER_PULSE;
-			return 0;
-		}
-
-		break;
-	}
-	debug_log_printk(dev, "dec failed\n");
-
-	data->state = STATE_INACTIVE;
-	return -EINVAL;
-}
-
-static struct remote_raw_handler xmp_handler = {
-	.protocols	= REMOTE_TYPE_RAW_XMP_1,
-	.decode		= ir_xmp_decode,
-};
-
-static int __init ir_xmp_decode_init(void)
-{
-	xmp_handler.data = kzalloc(sizeof(struct xmp_dec), GFP_KERNEL);
-	if (!xmp_handler.data) {
-		pr_err("%s: ir_xmp_decode_init alloc xmp_dec failure\n",
-					DRIVER_NAME);
-		return -1;
-	}
-	remote_raw_handler_register(&xmp_handler);
-
-	pr_info("%s: IR XMP protocol handler initialized\n", DRIVER_NAME);
-	return 0;
-}
-
-static void __exit ir_xmp_decode_exit(void)
-{
-	remote_raw_handler_unregister(&xmp_handler);
-	if (!xmp_handler.data)
-		kfree(xmp_handler.data);
-}
-
-module_init(ir_xmp_decode_init);
-module_exit(ir_xmp_decode_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("AMLOGIC");
-MODULE_DESCRIPTION("XMP IR PROTOCOL DECODER");
-
-
diff --git a/drivers/amlogic/input/remote/remote_func.c b/drivers/amlogic/input/remote/remote_func.c
new file mode 100644
index 000000000000..4b7ae95cede9
--- /dev/null
+++ b/drivers/amlogic/input/remote/remote_func.c
@@ -0,0 +1,1778 @@
+#include <asm/ioctl.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/errno.h>
+#include <asm/irq.h>
+#include <linux/io.h>
+/*#include <mach/am_regs.h>*/
+#include "remote_main.h"
+
+/*save the IR register*/
+#define REG_CACHE_SIZE 32
+unsigned int remote_reg_cache[REG_CACHE_SIZE];
+
+#ifdef REMOTE_FIQ
+#include <plat/fiq_bridge.h>
+#else
+#define fiq_bridge_pulse_trigger(x)
+#endif
+static DEFINE_SPINLOCK(remote_lock);
+
+#ifdef CONFIG_AML_HDMI_TX
+unsigned char cec_repeat = 10;
+#endif
+static const struct reg_s *remoteregsTab[] = {
+	RDECODEMODE_NEC,
+	RDECODEMODE_DUOKAN,
+	RDECODEMODE_MITSUBISHI,
+	RDECODEMODE_THOMSON,
+	RDECODEMODE_TOSHIBA,
+	RDECODEMODE_SONYSIRC,
+	RDECODEMODE_RC5,
+	RDECODEMODE_RESERVED,
+	RDECODEMODE_RC6,
+	RDECODEMODE_RCMM,
+	RDECODEMODE_COMCAST,
+	RDECODEMODE_SANYO,
+	RDECODEMODE_SKIPLEADER,
+	RDECODEMODE_SW,
+	RDECODEMODE_NEC_RCA_2IN1,
+	RDECODEMODE_NEC_TOSHIBA_2IN1,
+	RDECODEMODE_NEC_RCMM_2IN1,
+	RDECODEMODE_SW_NEC,
+	NULL,
+	RDECODEMODE_SW_DUOKAN
+};
+
+static int auto_repeat_count, repeat_count;
+static void remote_rel_timer_sr(unsigned long data);
+static void remote_repeat_sr(unsigned long data);
+static void remote_rca_repeat_sr(unsigned long data);
+static int dbg_printk(const char *fmt, ...)
+{
+	char buf[100];
+	va_list args;
+
+	va_start(args, fmt);
+	vscnprintf(buf, 100, fmt, args);
+	if (strlen(remote_log_buf) + (strlen(buf) + 64) > REMOTE_LOG_BUF_LEN)
+		remote_log_buf[0] = '\0';
+	strcat(remote_log_buf, buf);
+	va_end(args);
+	return 0;
+}
+
+int set_remote_mode(int mode)
+{
+	const struct reg_s *reg;
+	reg = remoteregsTab[mode];
+	while (CONFIG_END != reg->reg)
+		setremotereg(reg++);
+	input_dbg("%s[%d]\n", __func__, __LINE__);
+	return 0;
+
+}
+
+void setremotereg(const struct reg_s *r)
+{
+	am_remote_write_reg(r->reg, r->val);
+	pr_debug("[0x%lx] = 0x%x\n", (g_remote_ao_offset + ((r->reg) << 2)),
+		r->val);
+}
+
+int remote_save_regs(int mode)
+{
+	const struct reg_s *reg;
+	reg = remoteregsTab[mode];
+	while (CONFIG_END != reg->reg && reg->reg < REG_CACHE_SIZE) {
+		remote_reg_cache[reg->reg] = am_remote_read_reg(reg->reg);
+		reg++;
+	}
+	return 0;
+}
+
+int remote_restore_regs(int mode)
+{
+	const struct reg_s *reg;
+	reg = remoteregsTab[mode];
+	while (CONFIG_END != reg->reg && reg->reg < REG_CACHE_SIZE) {
+		am_remote_write_reg(reg->reg, remote_reg_cache[reg->reg]);
+		reg++;
+	}
+	return 0;
+}
+
+void config_sw_init_window(struct remote *remote_data)
+{
+	switch (remote_data->work_mode) {
+	case DECODEMODE_SW_NEC:
+		remote_data->bit_count = 32;
+		remote_data->debug_enable = 1;
+		remote_data->release_delay[remote_data->map_num] = 108;
+		remote_data->repeat_enable = 0;
+		remote_data->time_window[0] = 500;
+		remote_data->time_window[1] = 700;
+		remote_data->time_window[2] = 50;
+		remote_data->time_window[3] = 80;
+		remote_data->time_window[4] = 100;
+		remote_data->time_window[5] = 130;
+		remote_data->time_window[6] = 800;
+		remote_data->time_window[7] = 900;
+		break;
+	case DECODEMODE_SW_DUOKAN:
+		remote_data->bit_count = 20;
+		remote_data->debug_enable = 1;
+		remote_data->repeat_enable = 0;
+		remote_data->time_window[0] = 79;
+		remote_data->time_window[1] = 83;
+		remote_data->time_window[2] = 54;
+		remote_data->time_window[3] = 61;
+		remote_data->time_window[4] = 70;
+		remote_data->time_window[5] = 78;
+		remote_data->time_window[6] = 256;
+		remote_data->time_window[7] = 768;
+		remote_data->time_window[8] = 84;
+		remote_data->time_window[9] = 93;
+		remote_data->time_window[10] = 99;
+		remote_data->time_window[11] = 106;
+		break;
+	default:
+		break;
+
+	}
+
+}
+
+void kdb_send_key(struct input_dev *dev, unsigned int scancode,
+		  unsigned int type, int event);
+
+void set_remote_init(struct remote *remote_data)
+{
+	if (remote_data->work_mode <= DECODEMODE_MAX) {
+		if (remote_data->work_mode > DECODEMODE_NEC) {
+			if (remote_data->work_mode == DECODEMODE_NEC_RCA_2IN1)
+				setup_timer(&remote_data->repeat_timer,
+					    remote_rca_repeat_sr, 0);
+			else
+				setup_timer(&remote_data->repeat_timer,
+					    remote_repeat_sr, 0);
+			input_dbg("enter in sw repeat mode\n");
+		}
+		return;
+	}
+	config_sw_init_window(remote_data);
+}
+
+void changeduokandecodeorder(struct remote *remote_data)
+{
+	unsigned int scancode = remote_data->cur_lsbkeycode;
+	remote_data->cur_lsbkeycode =
+	    ((scancode & 0x3) << 18) | ((scancode & 0xc) << 14) |
+	    ((scancode & 0x30) << 10) | ((scancode & 0xc0) << 6) |
+	    ((scancode & 0x300) << 2) | ((scancode & 0xc00) >> 2) |
+	    ((scancode & 0x3000) >> 6) | ((scancode & 0xc000) >> 10) |
+	    ((scancode & 0x30000) >> 14) | ((scancode & 0xc0000) >> 18);
+	if (remote_data->cur_lsbkeycode == 0x0003cccf)
+		remote_data->cur_lsbkeycode =
+		    ((remote_data->custom_code[0] & 0xff) << 12) | 0xa0;
+}
+
+void get_cur_scancode(struct remote *remote_data)
+{
+	int temp_cur_lsbkeycode = 0;
+	if (remote_data->work_mode == DECODEMODE_SANYO) {
+		remote_data->cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
+		remote_data->cur_msbkeycode =
+		    am_remote_read_reg(FRAME_BODY1) & 0x2ff;
+	} else if (remote_data->work_mode == DECODEMODE_NEC_RCA_2IN1) {
+		temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
+		if (temp_cur_lsbkeycode != 0) {	/*new */
+			remote_data->temp_work_mode = DECODEMODE_RCA;
+			remote_data->cur_lsbkeycode = temp_cur_lsbkeycode;
+			temp_cur_lsbkeycode = 0;
+		}
+		if (am_remote_read_reg(DURATION_REG1_AND_STATUS - 0x40)
+		    >> 3 & 0x1) {	/*old */
+			temp_cur_lsbkeycode =
+			    am_remote_read_reg(FRAME_BODY - 0x40);
+			if (temp_cur_lsbkeycode != 0) {
+				remote_data->temp_work_mode = DECODEMODE_NEC;
+				remote_data->cur_lsbkeycode =
+				    temp_cur_lsbkeycode;
+				temp_cur_lsbkeycode = 0;
+			}
+		}
+	} else if (remote_data->work_mode == DECODEMODE_NEC_TOSHIBA_2IN1) {
+		temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
+		if (temp_cur_lsbkeycode != 0) {	/*new */
+			remote_data->temp_work_mode = DECODEMODE_TOSHIBA;
+			remote_data->cur_lsbkeycode = temp_cur_lsbkeycode;
+			temp_cur_lsbkeycode = 0;
+		}
+		if (am_remote_read_reg(DURATION_REG1_AND_STATUS - 0x40)
+		    >> 3 & 0x1) {	/*old */
+			temp_cur_lsbkeycode =
+			    am_remote_read_reg(FRAME_BODY - 0x40);
+			if (temp_cur_lsbkeycode != 0) {
+				remote_data->temp_work_mode = DECODEMODE_NEC;
+				remote_data->cur_lsbkeycode =
+				    temp_cur_lsbkeycode;
+				temp_cur_lsbkeycode = 0;
+			}
+		}
+	} else if (remote_data->work_mode == DECODEMODE_NEC_RCMM_2IN1) {
+		if (am_remote_read_reg(DURATION_REG1_AND_STATUS)>>3&0x1) {
+			/*new*/
+			temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
+		if (temp_cur_lsbkeycode) {
+			remote_data->temp_work_mode = DECODEMODE_RCMM;
+			remote_data->cur_lsbkeycode = temp_cur_lsbkeycode;
+			temp_cur_lsbkeycode = 0;
+			}
+		}
+		if (am_remote_read_reg(DURATION_REG1_AND_STATUS-0x40)>>3&0x1) {
+			/*old*/
+			temp_cur_lsbkeycode =
+			am_remote_read_reg(FRAME_BODY-0x40);
+		if (temp_cur_lsbkeycode) {
+			remote_data->temp_work_mode = DECODEMODE_NEC;
+			remote_data->cur_lsbkeycode =  temp_cur_lsbkeycode;
+			temp_cur_lsbkeycode = 0;
+			}
+		}
+
+	} else if (remote_data->work_mode > DECODEMODE_MAX) {
+		remote_data->cur_lsbkeycode = remote_data->cur_keycode;
+		if (remote_data->work_mode == DECODEMODE_SW_DUOKAN)
+			changeduokandecodeorder(remote_data);
+	} else
+		remote_data->cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
+
+}
+
+void get_cur_scanstatus(struct remote *remote_data)
+{
+	if (remote_data->work_mode == DECODEMODE_NEC_RCA_2IN1) {
+		if (remote_data->temp_work_mode == DECODEMODE_RCA)
+			remote_data->frame_status =
+			    am_remote_read_reg(DURATION_REG1_AND_STATUS);
+		if (remote_data->temp_work_mode == DECODEMODE_NEC)
+			remote_data->frame_status =
+			    am_remote_read_reg(DURATION_REG1_AND_STATUS - 0x40);
+
+	} else if (remote_data->work_mode == DECODEMODE_NEC_TOSHIBA_2IN1) {
+		if (remote_data->temp_work_mode == DECODEMODE_TOSHIBA) {
+			remote_data->frame_status =
+			    am_remote_read_reg(DURATION_REG1_AND_STATUS);
+			if (remote_data->cur_lsbkeycode == 0x1
+			    || remote_data->cur_lsbkeycode == 0x0) {
+				remote_data->frame_status = 0x1;
+				remote_data->cur_lsbkeycode = 0x0;
+			}
+
+		}
+		if (remote_data->temp_work_mode == DECODEMODE_NEC)
+			remote_data->frame_status =
+			    am_remote_read_reg(DURATION_REG1_AND_STATUS - 0x40);
+	} else if (remote_data->work_mode ==  DECODEMODE_NEC_RCMM_2IN1) {
+		if (remote_data->temp_work_mode == DECODEMODE_RCMM) {
+			remote_data->frame_status =
+				am_remote_read_reg(DURATION_REG1_AND_STATUS);
+			if (remote_data->cur_lsbkeycode == 0x1 ||
+				remote_data->cur_lsbkeycode == 0x0) {
+				remote_data->frame_status = 0x1;
+				remote_data->cur_lsbkeycode =  0x0;
+			}
+
+		}
+		if (remote_data->temp_work_mode == DECODEMODE_NEC) {
+			remote_data->frame_status =
+			am_remote_read_reg(DURATION_REG1_AND_STATUS-0x40);
+		}
+	} else
+		remote_data->frame_status =
+		    am_remote_read_reg(DURATION_REG1_AND_STATUS);
+
+}
+
+/*
+   DECODEMODE_NEC = 0,
+   DECODEMODE_SKIPLEADER,
+   DECODEMODE_SW,
+   DECODEMODE_MITSUBISHI,
+   DECODEMODE_THOMSON,
+   DECODEMODE_TOSHIBA,
+   DECODEMODE_SONYSIRC,
+   DECODEMODE_RC5,
+   DECODEMODE_RESERVED,
+   DECODEMODE_RC6,
+   DECODEMODE_RCMM,
+   DECODEMODE_DUOKAN,
+   DECODEMODE_RESERVED,
+   DECODEMODE_RESERVED,
+   DECODEMODE_COMCAST,
+   DECODEMODE_SANYO,
+   DECODEMODE_MAX*/
+
+unsigned int COMCAST_DOMAIN(struct remote *remote_data, int domain)
+{
+	return remote_data->cur_keycode & 0xff;
+}
+
+/*SANYO frame body
+  Leader + 13bit Address + 13bit (~Address) + 8bit Data + 8bit (~Data)
+ */
+unsigned int SANYO_DOMAIN(struct remote *remote_data, int domain)
+{
+	if (domain) {
+		remote_data->frame_mode = 0;
+		return (remote_data->cur_lsbkeycode >> 8) & 0xff;
+	} else {
+		remote_data->frame_mode = 0;
+		return ((remote_data->cur_lsbkeycode >> 29) & 0x7) |
+		    ((remote_data->cur_msbkeycode << 3)
+		     & 0x1fff);
+	}
+}
+
+/*
+
+ */
+unsigned int RCMM_DOMAIN(struct remote *remote_data, int domain)
+{
+#if 1
+	if (domain)
+		return (remote_data->cur_lsbkeycode) & 0xff;
+	else
+		return (remote_data->cur_lsbkeycode>>16) & 0xffff;
+
+#else
+	if (domain) {
+		if (((remote_data->cur_lsbkeycode >> 12) & 0xfff)) {
+			switch ((remote_data->cur_lsbkeycode >> 20) & 0xf) {
+			case 0x0:	/*OEM mode */
+				remote_data->frame_mode = 0;
+				return remote_data->cur_lsbkeycode & 0xff;
+			case 0x1:	/*Extended Mouse mode */
+				remote_data->frame_mode = 1;
+				break;
+			case 0x2:	/*Extended Keyboard mode */
+				remote_data->frame_mode = 2;
+				break;
+			case 0x3:	/*Extended Game pad mode */
+				remote_data->frame_mode = 3;
+				break;
+			}
+			return remote_data->cur_lsbkeycode & 0xfffff;
+		} else {
+			switch ((remote_data->cur_lsbkeycode >> 10) & 0x3) {
+			case 0x0:	/*OEM mode */
+				remote_data->frame_mode = 0;
+				return remote_data->cur_lsbkeycode & 0xff;
+			case 0x1:	/*Extended Mouse mode */
+				remote_data->frame_mode = 1;
+				break;
+			case 0x2:	/*Extended Keyboard mode */
+				remote_data->frame_mode = 2;
+				break;
+			case 0x3:	/*Extended Game pad mode */
+				remote_data->frame_mode = 3;
+				break;
+			}
+			return remote_data->cur_lsbkeycode & 0xff;
+		}
+	} else {
+		if (((remote_data->cur_lsbkeycode >> 12) & 0xfff)) {
+			switch ((remote_data->cur_lsbkeycode >> 20) & 0xf) {
+			case 0x0:	/*OEM mode */
+				remote_data->frame_mode = 0;
+				return remote_data->cur_lsbkeycode >> 12 & 0x3f;
+			case 0x1:	/*Extended Mouse mode */
+				remote_data->frame_mode = 1;
+				break;
+			case 0x2:	/*Extended Keyboard mode */
+				remote_data->frame_mode = 2;
+				break;
+			case 0x3:	/*Extended Game pad mode */
+				remote_data->frame_mode = 3;
+				break;
+			}
+			return 0;
+		} else {
+			switch ((remote_data->cur_lsbkeycode >> 20) & 0xf) {
+			case 0x0:	/*Extended mode */
+				remote_data->frame_mode = 0;
+			case 0x1:	/*Extended Mouse mode */
+				remote_data->frame_mode = 1;
+				break;
+			case 0x2:	/*Extended Keyboard mode */
+				remote_data->frame_mode = 2;
+				break;
+			case 0x3:	/*Extended Game pad mode */
+				remote_data->frame_mode = 3;
+				break;
+			}
+			return (remote_data->cur_lsbkeycode >> 8) & 0x3;
+		}
+	}
+#endif
+}
+
+/*
+   8 bit address and 8 bit command length
+   Address and command are transmitted twice for reliability
+   Pulse distance modulation
+   Carrier frequency of 38kHz
+   Bit time of 1.125ms or 2.25ms
+   NEC frame body
+   C15 ~ C8      C7 ~ C0    D15~D8      D7~D0
+   Header    ~Custom code   Custom code    Data Code ~Data Code
+ */
+unsigned int NEC_DOMAIN(struct remote *remote_data, int domain)
+{
+	if (domain) {		/*D15 ~ D8 */
+		return (remote_data->cur_lsbkeycode >> 16) & 0xff;
+	} else {		/* C7 ~ C0 */
+		return (remote_data->cur_lsbkeycode) & 0xffff;
+	}
+}
+
+/*
+   8 bit address and 8 bit command length
+   Pulse distance modulation
+   Carrier frequency of 38kHz
+   Bit time of 1ms or 2ms
+ */
+unsigned int MITSUBISHI_DOMAIN(struct remote *remote_data, int domain)
+{
+	if (domain)
+		return remote_data->cur_keycode & 0xff;
+	else
+		return (remote_data->cur_lsbkeycode >> 8) & 0xff;
+}
+
+unsigned int TOSHIBA_DOMAIN(struct remote *remote_data, int domain)
+{
+	if (domain)
+		return (remote_data->cur_lsbkeycode >> 16) & 0xff;
+	else
+		return (remote_data->cur_lsbkeycode) & 0xffff;
+}
+
+/*
+   Pulse width modulation
+   Carrier frequency of 40kHz
+   Bit time of 1.2ms or 0.6ms
+   5-bit address and 7-bit command length (12-bit protocol)
+ */
+
+unsigned int SONYSIRC_DOMAIN(struct remote *remote_data, int domain)
+{
+	if (domain)
+		return (remote_data->cur_lsbkeycode >> 5) & 0x7f;
+	else
+		return remote_data->cur_lsbkeycode & 0x1f;
+}
+
+unsigned int RC5_DOMAIN(struct remote *remote_data, int domain)
+{
+	if (domain)
+		return (remote_data->cur_lsbkeycode >> 5) & 0x7f;
+	else
+		return remote_data->cur_lsbkeycode & 0x1f;
+
+}
+
+unsigned int RC6_DOMAIN(struct remote *remote_data, int domain)
+{
+	if (domain)
+		return (remote_data->cur_lsbkeycode) & 0xff;
+	else
+		return (remote_data->cur_lsbkeycode >> 16) & 0xffff;
+
+}
+
+unsigned int RCA_DOMAIN(struct remote *remote_data, int domain)
+{
+	if (domain)
+		return (remote_data->cur_lsbkeycode) & 0xff;
+	else
+		return (remote_data->cur_lsbkeycode >> 8) & 0xf;
+
+}
+
+/*DUOKAN frame body OPERATION_CTRL_REG2 dd,0x0}, hard decode mode
+C7 ~ C4	 C3 ~ C0	D7 ~ D4      D3 ~ D0       P3 ~ P0
+Header	Custom code	Data Code  Parity Code    Stop Bit */
+unsigned int DUOKAN_DOMAIN(struct remote *remote_data, int domain)
+{
+	if (remote_data->cur_lsbkeycode == 0x0003cccf)	/* power key */
+		remote_data->cur_lsbkeycode =
+		    ((remote_data->custom_code[0] & 0xff) << 12) | 0xa4;
+	if (domain)
+		return (remote_data->cur_lsbkeycode >> 4) & 0xff;
+	else
+		return (remote_data->cur_lsbkeycode >> 12) & 0xff;
+}
+
+unsigned int KDB_NEC_DOMAIN(struct remote *remote_data, int domain)
+{
+	if (domain)
+		return (remote_data->cur_lsbkeycode >> 4) & 0xff;
+	else
+		return (remote_data->cur_lsbkeycode >> 12) & 0xff;
+}
+
+unsigned int KDB_DUOKAN_DOMAIN(struct remote *remote_data, int domain)
+{
+	if (domain)
+		return (remote_data->cur_lsbkeycode >> 4) & 0xff;
+	else
+		return (remote_data->cur_lsbkeycode >> 12) & 0xff;
+}
+
+unsigned int NULL_DUOKAN_DOMAIN(struct remote *remote_data, int domain)
+{
+	return 0;
+}
+
+unsigned int (*get_cur_key_domian[])
+(struct remote *remote_data, int domain) = {
+	NEC_DOMAIN,
+	DUOKAN_DOMAIN,
+	RCMM_DOMAIN,
+	KDB_NEC_DOMAIN,
+	COMCAST_DOMAIN,
+	MITSUBISHI_DOMAIN,
+	SONYSIRC_DOMAIN,
+	TOSHIBA_DOMAIN,
+	RC6_DOMAIN,
+	RC5_DOMAIN,
+	NULL_DUOKAN_DOMAIN,
+	RCA_DOMAIN,
+	NULL_DUOKAN_DOMAIN,
+	NULL_DUOKAN_DOMAIN,
+	NULL_DUOKAN_DOMAIN,
+	NULL_DUOKAN_DOMAIN,
+	NULL_DUOKAN_DOMAIN, NULL_DUOKAN_DOMAIN, KDB_DUOKAN_DOMAIN};
+
+int remote_hw_report_null_key(struct remote *remote_data)
+{
+	input_dbg("%s,it is a null key\n", __func__);
+	get_cur_scancode(remote_data);
+	get_cur_scanstatus(remote_data);
+	return 0;
+}
+
+irqreturn_t remote_null_bridge_isr(int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+
+
+/* 0-success other-failed */
+int remote_ig_custom_check(struct remote *rd)
+{
+	int workmode;
+	unsigned int customcode;
+	int i;
+
+	workmode = rd->work_mode;
+	customcode = get_cur_key_domian[workmode](rd, CUSTOMDOMAIN);
+
+	for (i = 0; i < ARRAY_SIZE(rd->custom_code); i++) {
+		if (rd->custom_code[i] == customcode) {
+			rd->map_num = i;
+			return 0;
+		}
+	}
+
+	input_dbg("Wrong custom code 0x%08x\n",	rd->cur_lsbkeycode);
+	return -1;
+}
+
+
+int remote_hw_report_key(struct remote *remote_data)
+{
+	static int last_scan_code;
+	int i;
+	get_cur_scancode(remote_data);
+	get_cur_scanstatus(remote_data);
+	if (remote_data->status)/* repeat enable & come in S timer is open */
+		return 0;
+	if (remote_data->cur_lsbkeycode) {	/*key first press */
+		if (remote_data->ig_custom_enable) {
+			for (i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
+				if (remote_data->custom_code[i] !=
+				    get_cur_key_domian[remote_data->work_mode]
+				    (remote_data, CUSTOMDOMAIN)) {
+					/*return -1; */
+					i++;
+				} else {
+					remote_data->map_num = i;
+					break;
+				}
+				if (i == ARRAY_SIZE(remote_data->custom_code)) {
+					input_dbg
+					    ("Wrong custom code is 0x%08x\n",
+					     remote_data->cur_lsbkeycode);
+					return -1;
+				}
+			}
+		}
+		repeat_count = 0;
+		if (time_before(jiffies, remote_data->timer.expires))
+			remote_data->remote_send_key(remote_data->input,
+						     remote_data->
+						     repeat_release_code, 0, 0);
+
+		remote_data->remote_send_key(remote_data->input,
+					     get_cur_key_domian
+					     [remote_data->work_mode]
+					     (remote_data, KEYDOMIAN), 1, 0);
+		remote_data->repeat_release_code =
+		    get_cur_key_domian[remote_data->work_mode] (remote_data,
+								KEYDOMIAN);
+		remote_data->enable_repeat_falg = 1;
+		if ((remote_data->work_mode > DECODEMODE_NEC) &&
+		    remote_data->enable_repeat_falg) {
+			if (remote_data->repeat_enable) {
+				remote_data->repeat_timer.data =
+				    (unsigned long)remote_data;
+				/*here repeat  delay is time interval from the
+				   first frame end to first repeat end. */
+				remote_data->repeat_tick = jiffies;
+				mod_timer(&remote_data->repeat_timer,
+					  jiffies +
+					  msecs_to_jiffies
+					  (remote_data->repeat_delay
+					   [remote_data->map_num]));
+				remote_data->status = TIMER;
+			} else {
+				setup_timer(&remote_data->rel_timer,
+					    remote_rel_timer_sr, 0);
+				mod_timer(&remote_data->timer, jiffies);
+				remote_data->rel_timer.data =
+				    (unsigned long)remote_data;
+				mod_timer(&remote_data->rel_timer,
+					  jiffies +
+					  msecs_to_jiffies
+					  (remote_data->relt_delay
+					   [remote_data->map_num]));
+				remote_data->status = TIMER;
+			}
+		}
+		for (i = 0;
+		     i <
+		     ARRAY_SIZE(remote_data->key_repeat_map
+				[remote_data->map_num]); i++) {
+			if (remote_data->key_repeat_map[remote_data->map_num][i]
+			    == remote_data->repeat_release_code)
+				remote_data->want_repeat_enable = 1;
+			else
+				remote_data->want_repeat_enable = 0;
+		}
+
+		if (remote_data->repeat_enable
+		    && remote_data->want_repeat_enable)
+			remote_data->repeat_tick =
+			    jiffies +
+			    msecs_to_jiffies(remote_data->repeat_delay
+					     [remote_data->map_num]);
+		if (remote_data->repeat_enable)
+			mod_timer(&remote_data->timer,
+				  jiffies +
+				  msecs_to_jiffies(remote_data->release_delay
+						   [remote_data->map_num] +
+						   remote_data->repeat_delay
+						   [remote_data->map_num]));
+		else
+			mod_timer(&remote_data->timer,
+				  jiffies +
+				  msecs_to_jiffies(remote_data->release_delay
+						   [remote_data->map_num] +
+						   remote_data->repeat_delay
+						   [remote_data->map_num]));
+	} else if ((remote_data->frame_status & REPEARTFLAG) &&
+			remote_data->enable_repeat_falg) {	/*repeate key */
+#ifdef CONFIG_AML_HDMI_TX
+		if ((remote_data->repeat_release_code == 0x1a) &&
+						(!cec_repeat)) {
+			/*rc_long_press_pwr_key = 1; */
+			cec_repeat = 10;
+		}
+		if (remote_data->repeat_release_code == 0x1a)
+			cec_repeat--;
+
+#endif
+		if (remote_data->repeat_enable) {
+			repeat_count++;
+			if (time_after(jiffies, remote_data->repeat_tick)) {
+				if (repeat_count > 3)
+					remote_data->remote_send_key
+					    (remote_data->input,
+					     remote_data->repeat_release_code,
+					     2, 0);
+				remote_data->repeat_tick +=
+				    msecs_to_jiffies(remote_data->repeat_peroid
+						     [remote_data->map_num]);
+			}
+		} else {
+			if (time_before(jiffies, remote_data->timer.expires))
+				mod_timer(&remote_data->timer,
+					  jiffies +
+					  msecs_to_jiffies
+					  (remote_data->release_delay
+					   [remote_data->map_num]));
+			/*return -1;*/
+		}
+		mod_timer(&remote_data->timer,
+			  jiffies +
+			  msecs_to_jiffies(remote_data->release_delay
+					   [remote_data->map_num]) +
+			  msecs_to_jiffies(110));
+	}
+	last_scan_code = remote_data->cur_lsbkeycode;
+	remote_data->cur_keycode = last_scan_code;
+	remote_data->cur_lsbkeycode = 0;
+	remote_data->timer.data = (unsigned long)remote_data;
+	return 0;
+}
+
+int remote_duokan_parity_check(struct remote *remote_data)
+{
+	unsigned int data;
+	unsigned int code;
+	unsigned int c74, c30, d74, d30, p30;
+
+	code = remote_data->cur_lsbkeycode;
+	c74 = (code >> 16) & 0xF;
+	c30 = (code >> 12) & 0xF;
+	d74 = (code >> 8)  & 0xF;
+	d30 = (code >> 4)  & 0xF;
+	p30 = (code >> 0)  & 0xF;
+
+	data = c74 ^ c30 ^ d74 ^ d30;
+
+	if (p30 == data) {
+		input_dbg("parity check ok code=0x%x p30=0x%x parity=0x%x\n",
+			code, p30, data);
+		return 0;
+	} else {
+		input_dbg("parity check error code=0x%x p30=0x%x parity=0x%x\n",
+			code, p30, data);
+		remote_data->cur_lsbkeycode = 0;
+		return -1;
+	}
+}
+
+/* 1:frame is repeat 0: frame is normal */
+int is_repeat_key(struct remote *rd)
+{
+	return rd->frame_status & 0x1; /* bit0 */
+}
+
+int remote_duokan_report_key(struct remote *rd)
+{
+	static int last_scan_code;
+	unsigned long flags;
+	int ret;
+	unsigned int keycode;
+	int workmode;
+	unsigned int releasedelay;
+	unsigned long jiffies_old;
+	int parity_flags = 0x00;
+
+	get_cur_scanstatus(rd);
+	get_cur_scancode(rd);
+
+	parity_flags = 0x00;
+	ret = remote_duokan_parity_check(rd);
+	if (ret)
+		parity_flags = 0x01;
+
+	workmode = rd->work_mode;
+	keycode = get_cur_key_domian[workmode](rd, KEYDOMIAN);
+
+	spin_lock_irqsave(&remote_lock, flags);
+
+	if  (!parity_flags && !is_repeat_key(rd)) {
+		rd->jiffies_new = rd->jiffies_irq;
+		jiffies_old = rd->jiffies_old;
+		rd->jiffies_old = rd->jiffies_new;
+
+		rd->jiffies_old = rd->jiffies_new;
+		if (rd->keystate == RC_KEY_STATE_UP) {
+			if (rd->ig_custom_enable &&
+				remote_ig_custom_check(rd)) {
+				spin_unlock_irqrestore(&remote_lock, flags);
+				return -1;
+			}
+
+			rd->remote_send_key(rd->input, keycode, 1, 0);
+			rd->keystate = RC_KEY_STATE_DN;
+			auto_repeat_count++;
+			rd->repeat_release_code = keycode;
+			rd->enable_repeat_falg = 1;
+		} else {
+			input_dbg("abnormal frame come up\n");
+		}
+	}
+
+	if (rd->keystate == RC_KEY_STATE_DN) {
+		last_scan_code = rd->cur_lsbkeycode;
+		rd->cur_keycode = last_scan_code;
+		rd->cur_lsbkeycode = 0;
+		rd->timer.data = (unsigned long)rd;
+		releasedelay = rd->release_delay[rd->map_num];
+		input_dbg("ready to release keycode=0x%x\n", rd->cur_keycode);
+		mod_timer(&rd->timer, jiffies + msecs_to_jiffies(releasedelay));
+	}
+
+	spin_unlock_irqrestore(&remote_lock, flags);
+#if 0
+	if (remote_data->status) {/* repeat enable & come in S timer is open */
+		mod_timer(&remote_data->timer,
+			jiffies +
+			msecs_to_jiffies(remote_data->release_delay
+			[remote_data->map_num] +
+			remote_data->repeat_delay
+			[remote_data->map_num]));
+		return 0;
+	}
+	if (remote_data->cur_lsbkeycode) {	/*key first press */
+		if (remote_data->ig_custom_enable) {
+			for (i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
+				if (remote_data->custom_code[i] !=
+				    get_cur_key_domian[remote_data->work_mode]
+				    (remote_data, CUSTOMDOMAIN)) {
+					/*return -1; */
+					i++;
+				} else {
+					remote_data->map_num = i;
+					break;
+				}
+				if (i == ARRAY_SIZE(remote_data->custom_code)) {
+					input_dbg
+					    ("Wrong custom code is 0x%08x\n",
+					     remote_data->cur_lsbkeycode);
+					return -1;
+				}
+			}
+		}
+		repeat_count = 0;
+#if 0
+		if (time_before(jiffies, remote_data->timer.expires))	{
+			remote_data->remote_send_key(remote_data->input,
+						     remote_data->
+						     repeat_release_code, 0, 0);
+		}
+#endif
+		remote_data->remote_send_key(remote_data->input,
+					     get_cur_key_domian
+					     [remote_data->work_mode]
+					     (remote_data, KEYDOMIAN), 1, 0);
+
+		remote_data->repeat_release_code =
+		    get_cur_key_domian[remote_data->work_mode] (remote_data,
+								KEYDOMIAN);
+		remote_data->enable_repeat_falg = 1;
+		if ((remote_data->work_mode > DECODEMODE_NEC) &&
+		    remote_data->enable_repeat_falg) {
+			#if 1
+			{
+				remote_data->repeat_timer.data =
+				    (unsigned long)remote_data;
+				/*here repeat  delay is time interval from the
+				   first frame end to first repeat end. */
+				remote_data->repeat_tick = jiffies;
+				mod_timer(&remote_data->repeat_timer,
+					  jiffies +
+					  msecs_to_jiffies
+					  (remote_data->repeat_delay
+					   [remote_data->map_num]));
+				remote_data->status = TIMER;
+			}
+			#else
+				setup_timer(&remote_data->rel_timer,
+					    remote_rel_timer_sr, 0);
+				mod_timer(&remote_data->timer, jiffies);
+				remote_data->rel_timer.data =
+				    (unsigned long)remote_data;
+				mod_timer(&remote_data->rel_timer,
+					  jiffies +
+					  msecs_to_jiffies
+					  (remote_data->relt_delay
+					   [remote_data->map_num]));
+				remote_data->status = TIMER;
+
+			#endif
+		}
+		for (i = 0;
+		     i <
+		     ARRAY_SIZE(remote_data->key_repeat_map
+				[remote_data->map_num]); i++) {
+			if (remote_data->key_repeat_map[remote_data->map_num][i]
+			    == remote_data->repeat_release_code)
+				remote_data->want_repeat_enable = 1;
+			else
+				remote_data->want_repeat_enable = 0;
+		}
+
+		if (remote_data->repeat_enable
+		    && remote_data->want_repeat_enable)
+			remote_data->repeat_tick =
+			    jiffies +
+			    msecs_to_jiffies(remote_data->repeat_delay
+					     [remote_data->map_num]);
+		if (remote_data->repeat_enable)
+			mod_timer(&remote_data->timer,
+				  jiffies +
+				  msecs_to_jiffies(remote_data->release_delay
+						   [remote_data->map_num] +
+						   remote_data->repeat_delay
+						   [remote_data->map_num]));
+		else
+			mod_timer(&remote_data->timer,
+				  jiffies +
+				  msecs_to_jiffies(remote_data->release_delay
+						   [remote_data->map_num] +
+						   remote_data->repeat_delay
+						   [remote_data->map_num]));
+	} else if ((remote_data->frame_status & REPEARTFLAG) &&
+			remote_data->enable_repeat_falg) {	/*repeate key */
+#ifdef CONFIG_AML_HDMI_TX
+		if ((remote_data->repeat_release_code == 0x1a) &&
+						(!cec_repeat)) {
+			/*rc_long_press_pwr_key = 1; */
+			cec_repeat = 10;
+		}
+		if (remote_data->repeat_release_code == 0x1a)
+			cec_repeat--;
+
+#endif
+		if (remote_data->repeat_enable) {
+			repeat_count++;
+			if (time_after(jiffies, remote_data->repeat_tick)) {
+				if (repeat_count > 1)
+					remote_data->remote_send_key
+					    (remote_data->input,
+					     remote_data->repeat_release_code,
+					     2, 0);
+
+				remote_data->repeat_tick +=
+				    msecs_to_jiffies(remote_data->repeat_peroid
+						     [remote_data->map_num]);
+			}
+		} else {
+			if (time_before(jiffies, remote_data->timer.expires))
+				mod_timer(&remote_data->timer,
+					  jiffies +
+					  msecs_to_jiffies
+					  (remote_data->release_delay
+					   [remote_data->map_num]));
+			return -1;
+		}
+		mod_timer(&remote_data->timer,
+			  jiffies +
+			  msecs_to_jiffies(remote_data->release_delay
+					   [remote_data->map_num]) +
+			  msecs_to_jiffies(110));
+	}
+	last_scan_code = remote_data->cur_lsbkeycode;
+	remote_data->cur_keycode = last_scan_code;
+	remote_data->cur_lsbkeycode = 0;
+	remote_data->timer.data = (unsigned long)remote_data;
+#endif
+	return 0;
+}
+int remote_rc6_report_key(struct remote *remote_data)
+{
+	static int last_scan_code;
+	int i;
+
+	get_cur_scanstatus(remote_data);
+	get_cur_scancode(remote_data);
+	if (!auto_repeat_count) {
+		if (remote_data->cur_lsbkeycode) {	/*key first press */
+			if (remote_data->ig_custom_enable) {
+				for (i = 0; i < ARRAY_SIZE
+					(remote_data->custom_code);) {
+					if (remote_data->custom_code[i] !=
+						get_cur_key_domian
+						[remote_data->work_mode]
+						(remote_data, CUSTOMDOMAIN)) {
+						/*return -1; */
+						i++;
+					} else {
+						remote_data->map_num = i;
+						break;
+					}
+					if (i == ARRAY_SIZE
+						(remote_data->custom_code)) {
+						input_dbg
+						("Wrong custom code 0x%08x\n",
+						remote_data->cur_lsbkeycode);
+						return -1;
+				}
+			}
+		}
+
+	remote_data->remote_send_key(remote_data->input,
+		     get_cur_key_domian
+		     [remote_data->work_mode]
+		     (remote_data, KEYDOMIAN), 1, 0);
+			auto_repeat_count++;
+	remote_data->repeat_release_code =
+			get_cur_key_domian
+			[remote_data->work_mode]
+			(remote_data , KEYDOMIAN);
+		remote_data->enable_repeat_falg = 1;
+		}
+	}
+
+	mod_timer(&remote_data->timer,
+	  jiffies +
+	  msecs_to_jiffies(remote_data->release_delay
+			   [remote_data->map_num]));
+
+	last_scan_code = remote_data->cur_lsbkeycode;
+	remote_data->cur_keycode = last_scan_code;
+	remote_data->cur_lsbkeycode = 0;
+	remote_data->timer.data = (unsigned long)remote_data;
+	return 0;
+}
+
+int remote_hw_nec_rca_2in1_report_key(struct remote *remote_data)
+{
+	static int last_scan_code;
+	int i;
+	get_cur_scancode(remote_data);
+	get_cur_scanstatus(remote_data);
+	if (remote_data->status)/* repeat enable & come in S timer is open */
+		return 0;
+	if (remote_data->cur_lsbkeycode) {	/*key first press */
+		if (remote_data->ig_custom_enable) {
+			for (i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
+				if (remote_data->custom_code[i] !=
+				    get_cur_key_domian
+				    [remote_data->temp_work_mode]
+				    (remote_data, CUSTOMDOMAIN)) {
+					/*return -1; */
+					i++;
+				} else {
+					remote_data->map_num = i;
+					break;
+				}
+				if (i == ARRAY_SIZE(remote_data->custom_code)) {
+					input_dbg("Wrong custom code is 0x%08x,",
+						remote_data->cur_lsbkeycode);
+					input_dbg("temp_work_mode is %d\n",
+						remote_data->temp_work_mode);
+					return -1;
+				}
+			}
+		}
+		repeat_count = 0;
+		if (time_before(jiffies, remote_data->timer.expires))
+			remote_data->remote_send_key(remote_data->input,
+						     remote_data->
+						     repeat_release_code, 0, 0);
+		remote_data->remote_send_key(remote_data->input,
+					     get_cur_key_domian[remote_data->
+								temp_work_mode]
+					     (remote_data, KEYDOMIAN), 1, 0);
+		remote_data->repeat_release_code =
+		    get_cur_key_domian[remote_data->temp_work_mode]
+		    (remote_data, KEYDOMIAN);
+		remote_data->enable_repeat_falg = 1;
+		if ((remote_data->temp_work_mode == DECODEMODE_RCA) &&
+		    (remote_data->enable_repeat_falg)) {
+			if (remote_data->repeat_enable) {
+				remote_data->repeat_timer.data =
+				    (unsigned long)remote_data;
+				/*here repeat  delay is time interval
+				from the first frame end to first repeat end.*/
+				remote_data->repeat_tick = jiffies;
+				mod_timer(&remote_data->repeat_timer,
+					  jiffies +
+					  msecs_to_jiffies
+					  (remote_data->repeat_delay
+					   [remote_data->map_num]));
+				remote_data->status = TIMER;
+			} else {
+				setup_timer(&remote_data->rel_timer,
+					    remote_rel_timer_sr, 0);
+				mod_timer(&remote_data->timer, jiffies);
+				remote_data->rel_timer.data =
+				    (unsigned long)remote_data;
+				mod_timer(&remote_data->rel_timer,
+					  jiffies +
+					  msecs_to_jiffies
+					  (remote_data->relt_delay
+					   [remote_data->map_num]));
+				remote_data->status = TIMER;
+			}
+		}
+		for (i = 0;
+		     i <
+		     ARRAY_SIZE(remote_data->key_repeat_map
+				[remote_data->map_num]); i++) {
+			if (remote_data->key_repeat_map[remote_data->map_num][i]
+			    == remote_data->repeat_release_code)
+				remote_data->want_repeat_enable = 1;
+			else
+				remote_data->want_repeat_enable = 0;
+		}
+
+		if (remote_data->repeat_enable
+		    && remote_data->want_repeat_enable)
+			remote_data->repeat_tick =
+			    jiffies +
+			    msecs_to_jiffies(remote_data->repeat_delay
+					     [remote_data->map_num]);
+		if (remote_data->repeat_enable)
+			mod_timer(&remote_data->timer,
+				  jiffies +
+				  msecs_to_jiffies(remote_data->release_delay
+						   [remote_data->map_num] +
+						   remote_data->repeat_delay
+						   [remote_data->map_num]));
+		else
+			mod_timer(&remote_data->timer,
+				  jiffies +
+				  msecs_to_jiffies(remote_data->release_delay
+						   [remote_data->map_num] +
+						   remote_data->repeat_delay
+						   [remote_data->map_num]));
+	} else if ((remote_data->frame_status & REPEARTFLAG) &&
+			remote_data->enable_repeat_falg) {	/*repeate key */
+#ifdef CONFIG_AML_HDMI_TX
+		if ((remote_data->repeat_release_code == 0x1a)
+						&& (!cec_repeat)) {
+			/*rc_long_press_pwr_key = 1; */
+			cec_repeat = 10;
+		}
+		if (remote_data->repeat_release_code == 0x1a)
+			cec_repeat--;
+
+#endif
+		if (remote_data->repeat_enable) {
+			repeat_count++;
+			if (time_after(jiffies, remote_data->repeat_tick)) {
+				if (repeat_count > 1)
+					remote_data->remote_send_key
+					    (remote_data->input,
+					     remote_data->repeat_release_code,
+					     2, 0);
+				remote_data->repeat_tick +=
+				    msecs_to_jiffies(remote_data->repeat_peroid
+						     [remote_data->map_num]);
+			}
+		} else {
+			if (time_before(jiffies, remote_data->timer.expires))
+				mod_timer(&remote_data->timer,
+					  jiffies +
+					  msecs_to_jiffies
+					  (remote_data->release_delay
+					   [remote_data->map_num]));
+			return -1;
+		}
+		mod_timer(&remote_data->timer,
+			  jiffies +
+			  msecs_to_jiffies(remote_data->release_delay
+					   [remote_data->map_num]) +
+			  msecs_to_jiffies(110));
+	}
+	last_scan_code = remote_data->cur_lsbkeycode;
+	remote_data->cur_keycode = last_scan_code;
+	remote_data->cur_lsbkeycode = 0;
+	remote_data->timer.data = (unsigned long)remote_data;
+	return 0;
+}
+
+int remote_hw_nec_toshiba_2in1_report_key(struct remote *remote_data)
+{
+	static int last_scan_code;
+	int i;
+	get_cur_scancode(remote_data);
+	get_cur_scanstatus(remote_data);
+	if (remote_data->cur_lsbkeycode) {	/*key first press */
+		if (remote_data->ig_custom_enable) {
+			for (i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
+				if (remote_data->custom_code[i] !=
+				    get_cur_key_domian
+				    [remote_data->temp_work_mode]
+				    (remote_data, CUSTOMDOMAIN)) {
+					/*return -1; */
+					i++;
+				} else {
+					remote_data->map_num = i;
+					break;
+				}
+
+				if (i == ARRAY_SIZE(remote_data->custom_code)) {
+					input_dbg("Wrong custom code 0x%08x,",
+						remote_data->cur_lsbkeycode);
+					input_dbg("temp_work_mode is %d\n",
+						remote_data->temp_work_mode);
+					return -1;
+				}
+			}
+		}
+		repeat_count = 0;
+		if (time_before(jiffies, remote_data->timer.expires))
+			remote_data->remote_send_key(remote_data->input,
+						     remote_data->
+						     repeat_release_code, 0, 0);
+		remote_data->remote_send_key(remote_data->input,
+					     get_cur_key_domian[remote_data->
+								temp_work_mode]
+					     (remote_data, KEYDOMIAN), 1, 0);
+		remote_data->repeat_release_code =
+		    get_cur_key_domian[remote_data->temp_work_mode]
+		    (remote_data, KEYDOMIAN);
+		remote_data->enable_repeat_falg = 1;
+		if (remote_data->temp_work_mode == DECODEMODE_TOSHIBA) {
+			/* setting frame bit = 1; */
+			am_remote_write_reg(OPERATION_CTRL_REG1, 0x8000);
+		}
+		for (i = 0;
+		     i <
+		     ARRAY_SIZE(remote_data->key_repeat_map
+				[remote_data->map_num]); i++) {
+			if (remote_data->key_repeat_map[remote_data->map_num][i]
+			    == remote_data->repeat_release_code)
+				remote_data->want_repeat_enable = 1;
+			else
+				remote_data->want_repeat_enable = 0;
+		}
+
+		if (remote_data->repeat_enable
+		    && remote_data->want_repeat_enable)
+			remote_data->repeat_tick =
+			    jiffies +
+			    msecs_to_jiffies(remote_data->repeat_delay
+					     [remote_data->map_num]);
+		if (remote_data->repeat_enable)
+			mod_timer(&remote_data->timer,
+				  jiffies +
+				  msecs_to_jiffies(remote_data->release_delay
+						   [remote_data->map_num] +
+						   remote_data->repeat_delay
+						   [remote_data->map_num]));
+		else
+			mod_timer(&remote_data->timer,
+				  jiffies +
+				  msecs_to_jiffies(remote_data->release_delay
+						   [remote_data->map_num] +
+						   remote_data->repeat_delay
+						   [remote_data->map_num]));
+	} else if ((remote_data->frame_status & REPEARTFLAG) &&
+			remote_data->enable_repeat_falg) {/*repeate key */
+#ifdef CONFIG_AML_HDMI_TX
+		if ((remote_data->repeat_release_code == 0x1a)
+		    && (!cec_repeat)) {
+			/*rc_long_press_pwr_key = 1; */
+			cec_repeat = 10;
+		}
+		if (remote_data->repeat_release_code == 0x1a)
+			cec_repeat--;
+
+#endif
+		if (remote_data->repeat_enable) {
+			repeat_count++;
+			if (time_after(jiffies, remote_data->repeat_tick)) {
+				if (repeat_count > 3)
+					remote_data->remote_send_key
+					    (remote_data->input,
+					     remote_data->repeat_release_code,
+					     2, 0);
+				remote_data->repeat_tick +=
+				    msecs_to_jiffies(remote_data->repeat_peroid
+						     [remote_data->map_num]);
+			}
+		} else {
+			if (time_before(jiffies, remote_data->timer.expires))
+				mod_timer(&remote_data->timer,
+					  jiffies +
+					  msecs_to_jiffies
+					  (remote_data->release_delay
+					   [remote_data->map_num]));
+			/*return -1;*/
+		}
+		mod_timer(&remote_data->timer,
+			  jiffies +
+			  msecs_to_jiffies(remote_data->release_delay
+					   [remote_data->map_num]) +
+			  msecs_to_jiffies(110));
+	}
+	last_scan_code = remote_data->cur_lsbkeycode;
+	remote_data->cur_keycode = last_scan_code;
+	remote_data->cur_lsbkeycode = 0;
+	remote_data->timer.data = (unsigned long)remote_data;
+	return 0;
+}
+
+static inline void kbd_software_mode_remote_send_key(unsigned long data)
+{
+	struct remote *remote_data = (struct remote *)data;
+	int i;
+	get_cur_scancode(remote_data);
+	remote_data->step = REMOTE_STATUS_SYNC;
+	if (remote_data->repeate_flag) {
+		if (time_after(jiffies, remote_data->repeat_tick) &&
+		    (remote_data->enable_repeat_falg == 1)) {
+			remote_data->remote_send_key(remote_data->input,
+						     remote_data->
+						     repeat_release_code, 2, 0);
+			remote_data->repeat_tick +=
+			    msecs_to_jiffies(remote_data->input->
+					     rep[REP_PERIOD]);
+		}
+	} else {
+		if (remote_data->ig_custom_enable) {
+			for (i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
+				if (remote_data->custom_code[i] !=
+				    get_cur_key_domian[remote_data->work_mode]
+				    (remote_data, CUSTOMDOMAIN)) {
+					/*return -1; */
+					i++;
+				} else {
+					remote_data->map_num = i;
+					break;
+				}
+				if (i == ARRAY_SIZE(remote_data->custom_code)) {
+					input_dbg
+					    ("Wrong custom code is 0x%08x\n",
+					     remote_data->cur_lsbkeycode);
+					return;
+				}
+			}
+		}
+		remote_data->remote_send_key(remote_data->input,
+					     get_cur_key_domian
+					     [remote_data->work_mode]
+					     (remote_data, KEYDOMIAN), 1, 0);
+		remote_data->repeat_release_code =
+		    get_cur_key_domian[remote_data->work_mode] (remote_data,
+								KEYDOMIAN);
+		remote_data->enable_repeat_falg = 1;
+		for (i = 0;
+		     i <
+		     ARRAY_SIZE(remote_data->key_repeat_map
+				[remote_data->map_num]); i++) {
+			if (remote_data->key_repeat_map[remote_data->map_num][i]
+			    == remote_data->repeat_release_code)
+				remote_data->want_repeat_enable = 1;
+			else
+				remote_data->want_repeat_enable = 0;
+		}
+		if (remote_data->repeat_enable
+		    && remote_data->want_repeat_enable)
+			remote_data->repeat_tick =
+			    jiffies +
+			    msecs_to_jiffies(remote_data->input->
+					     rep[REP_DELAY]);
+	}
+}
+
+static void remote_rca_repeat_sr(unsigned long data)
+{
+	struct remote *remote_data = (struct remote *)data;
+	if (remote_data->cur_keycode == remote_data->cur_lsbkeycode) {
+		repeat_count++;
+		if (repeat_count > 2)
+			remote_data->remote_send_key(remote_data->input,
+						     remote_data->
+						     repeat_release_code, 2, 0);
+		remote_data->cur_lsbkeycode = 0;
+		remote_data->repeat_timer.data = (unsigned long)remote_data;
+		remote_data->timer.data = (unsigned long)remote_data;
+		mod_timer(&remote_data->timer,
+			  jiffies +
+			  msecs_to_jiffies(remote_data->release_delay
+					   [remote_data->map_num] +
+					   remote_data->repeat_peroid
+					   [remote_data->map_num]));
+		mod_timer(&remote_data->repeat_timer,
+			  jiffies +
+			  msecs_to_jiffies(remote_data->repeat_peroid
+					   [remote_data->map_num]));
+		remote_data->status = TIMER;
+	} else {
+		remote_data->status = NORMAL;
+		remote_data->timer.data = (unsigned long)remote_data;
+		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(1));
+	}
+}
+
+static void remote_repeat_sr(unsigned long data)
+{
+	struct remote *remote_data = (struct remote *)data;
+	if (remote_data->cur_keycode == remote_data->cur_lsbkeycode) {
+		auto_repeat_count++;
+		if (auto_repeat_count > 1) {
+			if (remote_data->repeat_enable)
+				remote_data->remote_send_key(remote_data->input,
+						     remote_data->
+						     repeat_release_code, 2, 0);
+		}
+		remote_data->cur_lsbkeycode = 0;
+		remote_data->repeat_timer.data = (unsigned long)remote_data;
+		remote_data->timer.data = (unsigned long)remote_data;
+		mod_timer(&remote_data->repeat_timer,
+			  jiffies +
+			  msecs_to_jiffies(remote_data->repeat_peroid
+					   [remote_data->map_num]));
+		remote_data->status = TIMER;
+	} else {
+		remote_data->status = NORMAL;
+		remote_data->timer.data = (unsigned long)remote_data;
+		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(1));
+	}
+}
+
+static void remote_rel_timer_sr(unsigned long data)
+{
+	struct remote *remote_data = (struct remote *)data;
+	if (remote_data->cur_keycode == remote_data->cur_lsbkeycode) {
+		remote_data->cur_lsbkeycode = 0;
+		remote_data->rel_timer.data = (unsigned long)remote_data;
+		mod_timer(&remote_data->rel_timer,
+			  jiffies +
+			  msecs_to_jiffies(remote_data->relt_delay
+					   [remote_data->map_num]));
+		remote_data->status = TIMER;
+	} else
+		remote_data->status = NORMAL;
+
+}
+
+static int get_pulse_width(struct remote *remote_data)
+{
+	unsigned int pulse_width;
+	const char *state;
+
+	pulse_width =
+	    (am_remote_read_reg(OPERATION_CTRL_REG1) & 0x1FFF0000) >> 16;
+	state =
+	    remote_data->step ==
+	    REMOTE_STATUS_WAIT ? "wait" : remote_data->step ==
+	    REMOTE_STATUS_LEADER ? "leader" : remote_data->step ==
+	    REMOTE_STATUS_DATA ? "data" : remote_data->step ==
+	    REMOTE_STATUS_SYNC ? "sync" : NULL;
+	dbg_printk("%02d:pulse_wdith:%d==>%s\r\n",
+		   remote_data->bit_count - remote_data->bit_num, pulse_width,
+		   state);
+	/*sometimes we found remote  pulse width==0.
+	   in order to sync machine state we modify it . */
+	if (pulse_width == 0) {
+		switch (remote_data->step) {
+		case REMOTE_STATUS_LEADER:
+			pulse_width = remote_data->time_window[0] + 1;
+			break;
+		case REMOTE_STATUS_DATA:
+			pulse_width = remote_data->time_window[2] + 1;
+			break;
+		}
+	}
+	return pulse_width;
+}
+
+static inline void kbd_software_mode_remote_wait(struct remote *remote_data)
+{
+	remote_data->step = REMOTE_STATUS_LEADER;
+	remote_data->cur_keycode = 0;
+	remote_data->bit_num = remote_data->bit_count;
+}
+
+static inline void kbd_software_mode_remote_leader(struct remote *remote_data)
+{
+	unsigned int pulse_width;
+	pulse_width = get_pulse_width(remote_data);
+	if ((pulse_width > remote_data->time_window[0])
+	    && (pulse_width < remote_data->time_window[1]))
+		remote_data->step = REMOTE_STATUS_DATA;
+	else
+		remote_data->step = REMOTE_STATUS_WAIT;
+
+	remote_data->cur_keycode = 0;
+	remote_data->bit_num = remote_data->bit_count;
+}
+
+static inline void kbd_software_mode_remote_data(struct remote *remote_data)
+{
+	unsigned int pulse_width;
+
+	pulse_width = get_pulse_width(remote_data);
+	remote_data->step = REMOTE_STATUS_DATA;
+	switch (remote_data->work_mode) {
+	case DECODEMODE_SW_NEC:
+		if ((pulse_width > remote_data->time_window[2])
+		    && (pulse_width < remote_data->time_window[3]))
+			remote_data->bit_num--;
+		else if ((pulse_width > remote_data->time_window[4])
+			 && (pulse_width < remote_data->time_window[5])) {
+			remote_data->bit_num--;
+			remote_data->cur_keycode |=
+			    1 << (remote_data->bit_count -
+				  remote_data->bit_num);
+		} else
+			remote_data->step = REMOTE_STATUS_WAIT;
+		if (remote_data->bit_num == 0) {
+			remote_data->repeate_flag = 0;
+			remote_data->send_data = 1;
+			fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
+		}
+		break;
+	case DECODEMODE_SW_DUOKAN:
+		if ((pulse_width > remote_data->time_window[2])
+		    && (pulse_width < remote_data->time_window[3]))
+			remote_data->bit_num -= 2;
+		else if ((pulse_width > remote_data->time_window[4])
+			 && (pulse_width < remote_data->time_window[5])) {
+			remote_data->cur_keycode |=
+			    1 << (remote_data->bit_count -
+				  remote_data->bit_num);
+			remote_data->bit_num -= 2;
+		} else if ((pulse_width > remote_data->time_window[8])
+			   && (pulse_width < remote_data->time_window[9])) {
+			remote_data->cur_keycode |=
+			    2 << (remote_data->bit_count -
+				  remote_data->bit_num);
+			remote_data->bit_num -= 2;
+		} else if ((pulse_width > remote_data->time_window[10])
+			   && (pulse_width < remote_data->time_window[11])) {
+			remote_data->cur_keycode |=
+			    3 << (remote_data->bit_count -
+				  remote_data->bit_num);
+			remote_data->bit_num -= 2;
+		} else
+			remote_data->step = REMOTE_STATUS_WAIT;
+		if (remote_data->bit_num == 0) {
+			remote_data->repeate_flag = 0;
+			remote_data->send_data = 1;
+			fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
+		}
+		break;
+	}
+}
+
+static inline void kbd_software_mode_remote_sync(struct remote *remote_data)
+{
+	unsigned int pulse_width;
+
+	pulse_width = get_pulse_width(remote_data);
+	if ((pulse_width > remote_data->time_window[6])
+	    && (pulse_width < remote_data->time_window[7])) {
+		remote_data->repeate_flag = 1;
+		if (remote_data->repeat_enable)
+			remote_data->send_data = 1;
+		else {
+			remote_data->step = REMOTE_STATUS_SYNC;
+			return;
+		}
+	}
+	remote_data->step = REMOTE_STATUS_SYNC;
+	fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
+
+}
+
+int remote_sw_report_key(struct remote *remote_data)
+{
+	int current_jiffies = jiffies;
+
+	if (((current_jiffies - remote_data->last_jiffies) > 20)
+	    && (remote_data->step <= REMOTE_STATUS_SYNC))
+		remote_data->step = REMOTE_STATUS_WAIT;
+	remote_data->last_jiffies = current_jiffies;
+	/*ignore a little msecs */
+	switch (remote_data->step) {
+	case REMOTE_STATUS_WAIT:
+		kbd_software_mode_remote_wait(remote_data);
+		break;
+	case REMOTE_STATUS_LEADER:
+		kbd_software_mode_remote_leader(remote_data);
+		break;
+	case REMOTE_STATUS_DATA:
+		kbd_software_mode_remote_data(remote_data);
+		break;
+	case REMOTE_STATUS_SYNC:
+		kbd_software_mode_remote_sync(remote_data);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+irqreturn_t remote_bridge_isr(int irq, void *dev_id)
+{
+	struct remote *remote_data = (struct remote *)dev_id;
+
+	if (remote_data->send_data) {	/*report key */
+		kbd_software_mode_remote_send_key((unsigned long)remote_data);
+		remote_data->send_data = 0;
+	}
+	remote_data->timer.data = (unsigned long)remote_data;
+	mod_timer(&remote_data->timer,
+		  jiffies +
+		  msecs_to_jiffies(remote_data->release_delay
+				   [remote_data->map_num]));
+	return IRQ_HANDLED;
+}
+
+void kdb_send_key(struct input_dev *dev, unsigned int scancode,
+		  unsigned int type, int event)
+{
+	return;
+}
+
+void remote_nec_report_release_key(struct remote *remote_data)
+{
+	if (remote_data->enable_repeat_falg) {
+		remote_data->remote_send_key(remote_data->input,
+					     remote_data->repeat_release_code,
+					     0, 0);
+		remote_data->enable_repeat_falg = 0;
+	}
+}
+
+void remote_duokan_report_release_key(struct remote *remote_data)
+{
+	if (remote_data->enable_repeat_falg) {
+		remote_data->remote_send_key(remote_data->input,
+					     remote_data->repeat_release_code,
+					     0, 0);
+		remote_data->keystate = RC_KEY_STATE_UP;
+		remote_data->enable_repeat_falg = 0;
+		auto_repeat_count = 0;
+	}
+}
+void remote_rc6_report_release_key(struct remote *remote_data)
+{
+	if (remote_data->enable_repeat_falg) {
+		remote_data->remote_send_key(remote_data->input,
+					     remote_data->repeat_release_code,
+					     0, 0);
+		remote_data->enable_repeat_falg = 0;
+
+		auto_repeat_count = 0;
+	}
+}
+
+void remote_sw_report_release_key(struct remote *remote_data)
+{
+	if (remote_data->enable_repeat_falg) {
+		remote_data->remote_send_key(remote_data->input,
+					     remote_data->repeat_release_code,
+					     0, 0);
+		remote_data->enable_repeat_falg = 0;
+	}
+}
+
+void remote_nec_rca_2in1_report_release_key(struct remote *remote_data)
+{
+	if (remote_data->enable_repeat_falg) {
+		remote_data->remote_send_key(remote_data->input,
+					     remote_data->repeat_release_code,
+					     0, 0);
+		remote_data->enable_repeat_falg = 0;
+	}
+}
+
+void remote_nec_toshiba_2in1_report_release_key(struct remote *remote_data)
+{
+	if (remote_data->enable_repeat_falg) {
+		remote_data->remote_send_key(remote_data->input,
+					     remote_data->repeat_release_code,
+					     0, 0);
+		remote_data->enable_repeat_falg = 0;
+		am_remote_write_reg(OPERATION_CTRL_REG1, 0x9f40);
+
+	}
+}
+int remote_hw_nec_rcmm_2in1_report_key(struct remote *remote_data)
+{
+	static int last_scan_code;
+	int i;
+	get_cur_scancode(remote_data);
+	get_cur_scanstatus(remote_data);
+	input_dbg("rcmm-%d-0x%08x\n", auto_repeat_count,
+					remote_data->cur_lsbkeycode);
+	if (!auto_repeat_count) {
+		if (remote_data->cur_lsbkeycode) {	/*key first press */
+			if (remote_data->ig_custom_enable) {
+				for (i = 0; i < ARRAY_SIZE
+					(remote_data->custom_code);) {
+					if (remote_data->custom_code[i] !=
+						get_cur_key_domian
+						[remote_data->temp_work_mode]
+						(remote_data, CUSTOMDOMAIN)) {
+						/*return -1; */
+						i++;
+					} else {
+						remote_data->map_num = i;
+						break;
+					}
+					if (i == ARRAY_SIZE
+						(remote_data->custom_code)) {
+						input_dbg
+						("Wrong custom code 0x%08x\n",
+						remote_data->cur_lsbkeycode);
+						return -1;
+				}
+			}
+		}
+
+	remote_data->remote_send_key(remote_data->input,
+		     get_cur_key_domian
+		     [remote_data->temp_work_mode]
+		     (remote_data, KEYDOMIAN), 1, 0);
+			auto_repeat_count++;
+	remote_data->repeat_release_code =
+			get_cur_key_domian
+			[remote_data->temp_work_mode]
+			(remote_data , KEYDOMIAN);
+		remote_data->enable_repeat_falg = 1;
+		}
+	}
+
+	mod_timer(&remote_data->timer,
+	  jiffies +
+	  msecs_to_jiffies(remote_data->release_delay
+			   [remote_data->map_num]));
+
+	last_scan_code = remote_data->cur_lsbkeycode;
+	remote_data->cur_keycode = last_scan_code;
+	remote_data->cur_lsbkeycode = 0;
+	remote_data->timer.data = (unsigned long)remote_data;
+	return 0;
+}
+void remote_nec_rcmm_2in1_report_release_key(struct remote *remote_data)
+{
+	if (remote_data->enable_repeat_falg) {
+		remote_data->remote_send_key(remote_data->input,
+			remote_data->repeat_release_code, 0, 0);
+		remote_data->enable_repeat_falg = 0;
+		/*am_remote_write_reg(OPERATION_CTRL_REG1,0x9f40);*/
+		auto_repeat_count = 0;
+	}
+	input_dbg("status reg:0x%08x|Framedata:0x%08x\n",
+		am_remote_read_reg(DURATION_REG1_AND_STATUS),
+		am_remote_read_reg(FRAME_BODY));
+}
+
+
+void remote_null_report_release_key(struct remote *remote_data)
+{
+
+}
diff --git a/drivers/amlogic/input/remote/remote_main.c b/drivers/amlogic/input/remote/remote_main.c
new file mode 100644
index 000000000000..18765f677a60
--- /dev/null
+++ b/drivers/amlogic/input/remote/remote_main.c
@@ -0,0 +1,983 @@
+/*
+ *
+ * Remote Driver
+ *
+ * Copyright (C) 2013 Amlogic Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/errno.h>
+#include <asm/irq.h>
+#include <linux/io.h>
+#include <linux/amlogic/scpi_protocol.h>
+
+
+/*#include <mach/pinmux.h>*/
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/of_platform.h>
+#include "remote_main.h"
+#include <linux/amlogic/cpu_version.h>
+#include <linux/amlogic/pm.h>
+#include <linux/of_address.h>
+#undef NEW_BOARD_LEARNING_MODE
+#define IR_CONTROL_DECODER_MODE     (3<<7)
+#define IR_CONTROL_SKIP_HEADER      (1<<7)
+#define IR_CONTROL_RESET            (1<<0)
+#define KEY_RELEASE_DELAY    200
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+static struct early_suspend early_suspend;
+#endif
+
+static bool key_pointer_switch = true;
+static unsigned int FN_KEY_SCANCODE = 0x3ff;
+static unsigned int OK_KEY_SCANCODE = 0x3ff;
+type_printk input_dbg;
+static DEFINE_MUTEX(remote_enable_mutex);
+static DEFINE_MUTEX(remote_file_mutex);
+static void remote_tasklet(unsigned long);
+static int remote_enable;
+static int NEC_REMOTE_IRQ_NO = -1;
+unsigned long g_remote_ao_offset;
+DECLARE_TASKLET_DISABLED(tasklet, remote_tasklet, 0);
+/*static int repeat_flag;*/
+static struct remote *gp_remote;
+char *remote_log_buf;
+/* use 20 map for this driver*/
+static __u16 key_map[20][512];
+
+#ifdef REMOTE_FIQ
+static  irqreturn_t (*remote_bridge_sw_isr[])(int irq, void *dev_id) = {
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_bridge_isr,
+	remote_bridge_isr,
+};
+#endif
+static  int (*remote_report_key[])(struct remote *remote_data) = {
+	remote_hw_report_key,
+	remote_duokan_report_key,
+	remote_hw_report_null_key,
+	remote_hw_report_null_key,
+	remote_hw_report_null_key,
+	remote_hw_report_null_key,
+	remote_hw_report_null_key,
+	remote_hw_report_null_key,
+	remote_rc6_report_key,
+	remote_hw_report_null_key,
+	remote_hw_report_null_key,
+	remote_hw_report_null_key,
+	remote_hw_report_null_key,
+	remote_hw_report_null_key,
+	remote_hw_nec_rca_2in1_report_key,
+	remote_hw_nec_toshiba_2in1_report_key,
+	remote_hw_nec_rcmm_2in1_report_key,
+	remote_sw_report_key
+};
+
+static  void (*remote_report_release_key[])(struct remote *remote_data) = {
+	remote_nec_report_release_key,
+	remote_duokan_report_release_key,
+	remote_null_report_release_key,
+	remote_null_report_release_key,
+	remote_null_report_release_key,
+	remote_null_report_release_key,
+	remote_null_report_release_key,
+	remote_null_report_release_key,
+	remote_rc6_report_release_key,
+	remote_null_report_release_key,
+	remote_null_report_release_key,
+	remote_null_report_release_key,
+	remote_null_report_release_key,
+	remote_null_report_release_key,
+	remote_nec_rca_2in1_report_release_key,
+	remote_nec_toshiba_2in1_report_release_key,
+	remote_nec_rcmm_2in1_report_release_key,
+	remote_sw_report_release_key
+};
+static __u16 mouse_map[20][6];
+int remote_printk(const char *fmt, ...)
+{
+	va_list args;
+	int r;
+
+	if (gp_remote->debug_enable == 0)
+		return 0;
+	pr_info("remote: ");
+	va_start(args, fmt);
+	r = vprintk(fmt, args);
+	va_end(args);
+	return r;
+}
+
+static int remote_mouse_event(struct input_dev *dev, unsigned int scancode,
+			      unsigned int type, bool flag)
+{
+
+	__u16 mouse_code = REL_X;
+	__s32 mouse_value = 0;
+	static unsigned int repeat_count;
+	__s32 move_accelerate[] = {0, 2, 2, 4, 4, 6, 8, 10, 12, 14, 16, 18};
+	unsigned int i;
+
+	if (flag)
+		return 1;
+	for (i = 0; i < ARRAY_SIZE(mouse_map[gp_remote->map_num]); i++)
+		if (mouse_map[gp_remote->map_num][i] == scancode)
+			break;
+
+	if (i >= ARRAY_SIZE(mouse_map[gp_remote->map_num]))
+		return -1;
+	switch (type) {
+	case 1:     /*press*/
+		repeat_count = 0;
+		break;
+	case 2:     /*repeat*/
+		if (repeat_count >= ARRAY_SIZE(move_accelerate) - 1)
+			repeat_count = ARRAY_SIZE(move_accelerate) - 1;
+		else
+			repeat_count++;
+	}
+	switch (i) {
+	case 0:
+		mouse_code = REL_X;
+		mouse_value = -(1 + move_accelerate[repeat_count]);
+		break;
+	case 1:
+		mouse_code = REL_X;
+		mouse_value = 1 + move_accelerate[repeat_count];
+		break;
+	case 2:
+		mouse_code = REL_Y;
+		mouse_value = -(1 + move_accelerate[repeat_count]);
+		break;
+	case 3:
+		mouse_code = REL_Y;
+		mouse_value = 1 + move_accelerate[repeat_count];
+		break;
+	case 4:     /*up*/
+		mouse_code = REL_WHEEL;
+		mouse_value = 0x1;
+		break;
+	case 5:
+		mouse_code = REL_WHEEL;
+		mouse_value = 0xffffffff;
+		break;
+
+	}
+	if (type) {
+		input_event(dev, EV_REL, mouse_code, mouse_value);
+		input_sync(dev);
+		switch (mouse_code) {
+		case REL_X:
+		case REL_Y:
+			input_dbg("mouse be %s moved %d.\n",
+				mouse_code == REL_X ? "horizontal" :
+							"vertical",
+							mouse_value);
+			break;
+		case REL_WHEEL:
+			input_dbg("mouse wheel move %s .\n",
+				mouse_value == 0x1 ? "up" : "down");
+			break;
+		}
+
+	}
+	return 0;
+}
+
+void remote_send_key(struct input_dev *dev, unsigned int scancode,
+		     unsigned int type, int event)
+{
+	if (scancode == FN_KEY_SCANCODE && type == 1) {
+		/* switch from key to pointer*/
+		if (key_pointer_switch) {
+			key_pointer_switch = false;
+			gp_remote->repeat_enable = 1;
+			gp_remote->input->rep[REP_DELAY] =
+				gp_remote->repeat_delay[gp_remote->map_num];
+			gp_remote->input->rep[REP_PERIOD] =
+				gp_remote->repeat_peroid[gp_remote->map_num];
+		}
+		/* switch from pointer to key*/
+		else {
+			key_pointer_switch = true;
+			gp_remote->repeat_enable = 0;
+			gp_remote->input->rep[REP_DELAY] = 0xffffffff;
+			gp_remote->input->rep[REP_PERIOD] = 0xffffffff;
+		}
+	}
+
+	if (scancode == OK_KEY_SCANCODE && key_pointer_switch == false) {
+		input_event(dev, EV_KEY, BTN_MOUSE, type);
+		input_sync(dev);
+
+		return;
+	}
+
+	if (remote_mouse_event(dev, scancode, type, key_pointer_switch)) {
+		if (scancode > ARRAY_SIZE(key_map[gp_remote->map_num])) {
+			input_dbg("scancode is 0x%04x, out of key mapping.\n",
+				scancode);
+			return;
+		}
+		if ((key_map[gp_remote->map_num][scancode] >= KEY_MAX)
+			|| (key_map[gp_remote->map_num][scancode] ==
+				KEY_RESERVED)){
+			input_dbg("scancode is 0x%04x,invalid key is 0x%04x.\n",
+					scancode,
+					key_map[gp_remote->map_num][scancode]);
+			return;
+		}
+
+		if (type == 2 &&
+			key_map[gp_remote->map_num][scancode] == 0x0074)
+			return;
+		else {
+			input_event(dev, EV_KEY,
+					key_map[gp_remote->map_num][scancode],
+					type);
+			input_sync(dev);
+		}
+
+		switch (type) {
+		case 0:
+			input_dbg("release ircode = 0x%02x,",
+					scancode);
+			input_dbg("scancode = 0x%04x, maptable = %d,code:0x%08x\n\n",
+					key_map[gp_remote->map_num][scancode],
+					gp_remote->map_num,
+					gp_remote->cur_lsbkeycode);
+			break;
+		case 1:
+			input_dbg("press ircode = 0x%02x,",
+					scancode);
+			input_dbg("scancode = 0x%04x,maptable = %d,code:0x%08x\n\n",
+					key_map[gp_remote->map_num][scancode],
+					gp_remote->map_num,
+					gp_remote->cur_lsbkeycode);
+			break;
+		case 2:
+			input_dbg("repeat ircode = 0x%02x,",
+					scancode);
+			input_dbg("scancode = 0x%04x, maptable = %d,code:0x%08x\n\n",
+					key_map[gp_remote->map_num][scancode],
+					gp_remote->map_num,
+					gp_remote->cur_lsbkeycode);
+			break;
+		}
+		if (gp_remote->sleep && scancode == 0x1a &&
+		    key_map[gp_remote->map_num][scancode] == 0x0074) {
+			input_dbg(" set 0x4853ffff\n");
+		}
+	}
+}
+
+static void disable_remote_irq(void)
+{
+	if (gp_remote->work_mode >= DECODEMODE_MAX)
+		disable_irq(NEC_REMOTE_IRQ_NO);
+}
+
+static void enable_remote_irq(void)
+{
+	if (gp_remote->work_mode >= DECODEMODE_MAX)
+		enable_irq(NEC_REMOTE_IRQ_NO);
+
+}
+
+void remote_reprot_key(struct remote *remote_data)
+{
+	remote_report_key[remote_data->work_mode](remote_data);
+}
+
+static void remote_release_timer_sr(unsigned long data)
+{
+	struct remote *remote_data = (struct remote *)data;
+	/*key report release use timer interrupt*/
+	remote_data->key_release_report =
+		remote_report_release_key[remote_data->work_mode];
+	remote_data->key_release_report(remote_data);
+}
+
+static irqreturn_t remote_interrupt(int irq, void *dev_id)
+{
+	gp_remote->jiffies_irq = jiffies;
+
+	tasklet_schedule(&tasklet);
+	return IRQ_HANDLED;
+}
+#ifdef REMOTE_FIQ
+static void remote_fiq_interrupt(void)
+{
+	remote_reprot_key(gp_remote);
+}
+#endif
+
+static void remote_tasklet(unsigned long data)
+{
+	struct remote *remote_data = (struct remote *)data;
+	remote_reprot_key(remote_data);
+}
+
+static ssize_t remote_log_buffer_show(struct device *dev,
+				      struct device_attribute *attr,
+					char *buf)
+{
+	int ret = 0;
+	ret = sprintf(buf, "%s\n", remote_log_buf);
+	remote_log_buf[0] = '\0';
+	return ret;
+}
+
+static ssize_t remote_enable_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", remote_enable);
+}
+static ssize_t remote_enable_store(struct device *dev,
+				   struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	int state;
+
+	if (sscanf(buf, "%u", &state) != 1)
+		return -EINVAL;
+
+	if ((state != 1) && (state != 0))
+		return -EINVAL;
+
+	mutex_lock(&remote_enable_mutex);
+	if (state != remote_enable) {
+		if (state)
+			enable_remote_irq();
+		else
+			disable_remote_irq();
+		remote_enable = state;
+	}
+	mutex_unlock(&remote_enable_mutex);
+
+	return strnlen(buf, count);
+}
+
+
+static ssize_t remote_powerkey_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	unsigned int val = 0;
+    // TODO(rgerganov): missing API in 4.9
+	//unsigned int ret;
+
+	//ret = scpi_get_usr_data(SCPI_CL_POWER, &val, 1);
+	//if (IS_ERR_VALUE(ret)) {
+	//	pr_info("scpi_get_usr_data error: val =0x%x\n", val);
+	//	return 0;
+	//}
+	return sprintf(buf, "powerkey = 0x%x\n", val);
+}
+
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, remote_enable_show,
+		   remote_enable_store);
+static DEVICE_ATTR(log_buffer, S_IRUGO , remote_log_buffer_show, NULL);
+static DEVICE_ATTR(powerkey, S_IRUGO , remote_powerkey_show, NULL);
+
+static int hardware_init(struct platform_device *pdev)
+{
+	struct pinctrl *p;
+	p = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(p)) {
+		input_dbg("hardware init fail, %ld\n", PTR_ERR(p));
+		return -1;
+	}
+	set_remote_mode(DECODEMODE_NEC);
+
+	gp_remote->jiffies_old = jiffies;
+	gp_remote->jiffies_new = jiffies;
+	gp_remote->keystate = RC_KEY_STATE_UP;
+
+	return request_irq(NEC_REMOTE_IRQ_NO, remote_interrupt, IRQF_SHARED,
+				"keypad",
+				(void *)remote_interrupt);
+}
+static int work_mode_config(unsigned int cur_mode)
+{
+
+#ifdef REMOTE_FIQ
+	struct irq_desc *desc = irq_to_desc(NEC_REMOTE_IRQ_NO);
+#endif
+	int ret;
+	input_dbg("cur_mode = %d\n", cur_mode);
+	if (cur_mode > DECODEMODE_MAX) {
+		/*g_remote_ao_offset = P_AO_IR_DEC_LDR_ACTIVE;//change to old
+		ir decode*/
+		input_dbg("Error!!! you are setting one invalid mode\n");
+		return -1;
+	}
+	set_remote_mode(cur_mode);
+	set_remote_init(gp_remote);
+	if (cur_mode == gp_remote->save_mode)
+		return 0;
+	if ((cur_mode <= DECODEMODE_MAX)  &&
+		(gp_remote->save_mode > DECODEMODE_MAX)) {
+#ifdef REMOTE_FIQ
+		unregister_fiq_bridge_handle(&gp_remote->fiq_handle_item);
+		free_fiq(NEC_REMOTE_IRQ_NO, &remote_fiq_interrupt);
+#endif
+		ret = request_irq(NEC_REMOTE_IRQ_NO, remote_interrupt,
+					IRQF_SHARED, "keypad",
+				  (void *)remote_interrupt);
+		if (ret < 0) {
+			input_dbg("request_irq failed, ret=%d.\n", ret);
+			return ret;
+		}
+	} else if ((cur_mode > DECODEMODE_MAX)  &&
+		   (gp_remote->save_mode < DECODEMODE_MAX)) {
+		free_irq(NEC_REMOTE_IRQ_NO, remote_interrupt);
+#ifdef REMOTE_FIQ
+		gp_remote->fiq_handle_item.handle =
+		remote_bridge_sw_isr[gp_remote->work_mode];
+		gp_remote->fiq_handle_item.key = (u32) gp_remote;
+		gp_remote->fiq_handle_item.name = "remote_bridge";
+		register_fiq_bridge_handle(&gp_remote->fiq_handle_item);
+		desc->depth++;
+		request_fiq(NEC_REMOTE_IRQ_NO, remote_fiq_interrupt);
+#endif
+	} else
+		input_dbg("do nothing\n");
+	gp_remote->save_mode = cur_mode;
+	return 0;
+}
+
+static int remote_config_open(struct inode *inode, struct file *file)
+{
+	file->private_data = gp_remote;
+	return 0;
+}
+
+static long remote_config_ioctl(struct file *filp, unsigned int cmd,
+				unsigned long args)
+{
+	struct remote *remote = (struct remote *)filp->private_data;
+	void __user *argp = (void __user *)args;
+	unsigned int val, i;
+	unsigned int ret;
+
+	if (args)
+		ret = copy_from_user(&val, argp, sizeof(unsigned long));
+	mutex_lock(&remote_file_mutex);
+	switch (cmd) {
+	case REMOTE_IOC_INFCODE_CONFIG:
+		remote->map_num = val;
+		break;
+	case REMOTE_IOC_RESET_KEY_MAPPING:
+		for (i = 0; i < ARRAY_SIZE(key_map[remote->map_num]); i++)
+			key_map[remote->map_num][i] = KEY_RESERVED;
+		for (i = 0; i < ARRAY_SIZE(mouse_map[remote->map_num]); i++)
+			mouse_map[remote->map_num][i] = 0xffff;
+		break;
+	case REMOTE_IOC_SET_REPEAT_KEY_MAPPING:
+		if ((val >> 16) >= ARRAY_SIZE(remote->key_repeat_map)) {
+			mutex_unlock(&remote_file_mutex);
+			return -1;
+		}
+		remote->key_repeat_map[remote->map_num][val >> 16] =
+							val & 0xffff;
+		break;
+	case REMOTE_IOC_SET_KEY_MAPPING:
+		if ((val >> 16) >= ARRAY_SIZE(key_map[remote->map_num])) {
+			mutex_unlock(&remote_file_mutex);
+			return -1;
+		}
+		key_map[remote->map_num][val >> 16] = val & 0xffff;
+		break;
+	case REMOTE_IOC_SET_MOUSE_MAPPING:
+		if ((val >> 16) >= ARRAY_SIZE(mouse_map[remote->map_num])) {
+			mutex_unlock(&remote_file_mutex);
+			return -1;
+		}
+		mouse_map[remote->map_num][val >> 16] = val & 0xff;
+		break;
+	case REMOTE_IOC_SET_RELT_DELAY:
+		ret = copy_from_user(&remote->relt_delay[remote->map_num],
+					argp, sizeof(long));
+		break;
+	case REMOTE_IOC_SET_REPEAT_DELAY:
+		ret = copy_from_user(&remote->repeat_delay[remote->map_num],
+					argp,
+					sizeof(long));
+		break;
+	case REMOTE_IOC_SET_REPEAT_PERIOD:
+		ret = copy_from_user(&remote->repeat_peroid[remote->map_num],
+					argp,
+					sizeof(long));
+		break;
+	case REMOTE_IOC_SET_REPEAT_ENABLE:
+		ret = copy_from_user(&remote->repeat_enable, argp,
+					sizeof(long));
+		break;
+	case REMOTE_IOC_SET_DEBUG_ENABLE:
+		ret = copy_from_user(&remote->debug_enable, argp,
+							sizeof(long));
+		break;
+	case REMOTE_IOC_SET_MODE:
+		ret = copy_from_user(&remote->work_mode, argp, sizeof(long));
+		break;
+	case REMOTE_IOC_SET_BIT_COUNT:
+		ret = copy_from_user(&remote->bit_count, argp, sizeof(long));
+		break;
+	case REMOTE_IOC_SET_CUSTOMCODE:
+		ret = copy_from_user(&remote->custom_code[remote->map_num],
+							argp, sizeof(long));
+		break;
+	case REMOTE_IOC_SET_REG_BASE_GEN:
+		am_remote_write_reg(OPERATION_CTRL_REG0, val);
+		break;
+	case REMOTE_IOC_SET_REG_CONTROL:
+		am_remote_write_reg(DURATION_REG1_AND_STATUS, val);
+		break;
+	case REMOTE_IOC_SET_REG_LEADER_ACT:
+		am_remote_write_reg(LDR_ACTIVE, val);
+		break;
+	case REMOTE_IOC_SET_REG_LEADER_IDLE:
+		am_remote_write_reg(LDR_IDLE, val);
+		break;
+	case REMOTE_IOC_SET_REG_REPEAT_LEADER:
+		am_remote_write_reg(LDR_REPEAT, val);
+		break;
+	case REMOTE_IOC_SET_REG_BIT0_TIME:
+		am_remote_write_reg(DURATION_REG0, val);
+		break;
+	case REMOTE_IOC_SET_RELEASE_DELAY:
+		ret = copy_from_user(&remote->release_delay[remote->map_num],
+					argp,
+				sizeof(long));
+		break;
+	/*SW*/
+	case REMOTE_IOC_SET_TW_LEADER_ACT:
+		remote->time_window[0] = val & 0xffff;
+		remote->time_window[1] = (val >> 16) & 0xffff;
+		break;
+	case REMOTE_IOC_SET_TW_BIT0_TIME:
+		remote->time_window[2] = val & 0xffff;
+		remote->time_window[3] = (val >> 16) & 0xffff;
+		break;
+	case REMOTE_IOC_SET_TW_BIT1_TIME:
+		remote->time_window[4] = val & 0xffff;
+		remote->time_window[5] = (val >> 16) & 0xffff;
+		break;
+	case REMOTE_IOC_SET_TW_REPEATE_LEADER:
+		remote->time_window[6] = val & 0xffff;
+		remote->time_window[7] = (val >> 16) & 0xffff;
+		break;
+	case REMOTE_IOC_SET_TW_BIT2_TIME:
+		remote->time_window[8] = val & 0xffff;
+		remote->time_window[9] = (val >> 16) & 0xffff;
+		break;
+	case REMOTE_IOC_SET_TW_BIT3_TIME:
+		remote->time_window[10] = val & 0xffff;
+		remote->time_window[11] = (val >> 16) & 0xffff;
+		break;
+	case REMOTE_IOC_SET_FN_KEY_SCANCODE:
+		FN_KEY_SCANCODE = val;
+		break;
+	case REMOTE_IOC_SET_OK_KEY_SCANCODE:
+		OK_KEY_SCANCODE = val;
+		break;
+	}
+	/*output result*/
+	switch (cmd) {
+	case REMOTE_IOC_SET_REPEAT_ENABLE:
+		if (remote->repeat_enable) {
+			remote->input->rep[REP_DELAY] =
+				remote->repeat_delay[remote->map_num];
+			remote->input->rep[REP_PERIOD] =
+				remote->repeat_peroid[remote->map_num];
+		} else {
+			remote->input->rep[REP_DELAY] = 0xffffffff;
+			remote->input->rep[REP_PERIOD] = 0xffffffff;
+		}
+		break;
+	case REMOTE_IOC_SET_MODE:
+		work_mode_config(remote->work_mode);
+		break;
+	case REMOTE_IOC_GET_REG_BASE_GEN:
+	case REMOTE_IOC_GET_REG_CONTROL:
+	case REMOTE_IOC_GET_REG_LEADER_ACT:
+	case REMOTE_IOC_GET_REG_LEADER_IDLE:
+	case REMOTE_IOC_GET_REG_REPEAT_LEADER:
+	case REMOTE_IOC_GET_REG_BIT0_TIME:
+	case REMOTE_IOC_GET_REG_FRAME_DATA:
+	case REMOTE_IOC_GET_REG_FRAME_STATUS:
+	case REMOTE_IOC_GET_TW_LEADER_ACT:
+	case REMOTE_IOC_GET_TW_BIT0_TIME:
+	case REMOTE_IOC_GET_TW_BIT1_TIME:
+	case REMOTE_IOC_GET_TW_REPEATE_LEADER:
+		ret = copy_to_user(argp, &val, sizeof(long));
+		break;
+	case REMOTE_IOC_GET_POWERKEY:
+        pr_info("unsupported in 4.9\n");
+        mutex_unlock(&remote_file_mutex);
+        return -1;
+        //TODO(rgerganov): missing API in 4.9
+		//ret = scpi_get_usr_data(SCPI_CL_POWER, &val, 1);
+		//if (IS_ERR_VALUE(ret)) {
+		//	pr_info("scpi_get_usr_data SCPI_CL_POWER error\n");
+		//	mutex_unlock(&remote_file_mutex);
+		//	return -1;
+		//}
+		//ret = copy_to_user(argp, &val, sizeof(long));
+		//break;
+	}
+	mutex_unlock(&remote_file_mutex);
+	return 0;
+}
+
+static int remote_config_release(struct inode *inode, struct file *file)
+{
+	file->private_data = NULL;
+	return 0;
+}
+
+static const struct file_operations remote_fops = {
+	.owner = THIS_MODULE,
+	.open = remote_config_open,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl =	remote_config_ioctl,
+#endif
+	.unlocked_ioctl = remote_config_ioctl,
+	.release = remote_config_release,
+};
+
+static int register_remote_dev(struct remote *remote)
+{
+	int ret = 0;
+	strcpy(remote->config_name, "amremote");
+	ret = register_chrdev(0, remote->config_name, &remote_fops);
+	if (ret <= 0) {
+		input_dbg("register char dev tv error\r\n");
+		return ret;
+	}
+	remote->config_major = ret;
+	input_dbg("remote config major:%d\r\n", ret);
+	remote->config_class = class_create(THIS_MODULE, remote->config_name);
+	remote->config_dev = device_create(remote->config_class, NULL,
+					   MKDEV(remote->config_major, 0),
+						NULL, remote->config_name);
+	return ret;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void remote_early_suspend(struct early_suspend *handler)
+{
+	input_dbg("remote_early_suspend, set sleep 1\n");
+	gp_remote->sleep = 1;
+	return;
+}
+#endif
+
+static const struct of_device_id remote_dt_match[] = {
+	{
+		.compatible     = "amlogic, aml_remote",
+	},
+	{},
+};
+
+
+static int remote_probe(struct platform_device *pdev)
+{
+	struct remote *remote;
+	struct input_dev *input_dev;
+	int ao_offset;
+	struct resource *res_irq;
+	int i, ret;
+
+	/*aml_set_reg32_mask(P_AO_RTI_PIN_MUX_REG, (1 << 0));*/
+	if (!pdev->dev.of_node) {
+		pr_err("remote: pdev->dev.of_node == NULL!\n");
+		return -1;
+	}
+	ret = of_property_read_u32(pdev->dev.of_node, "remote_ao_offset",
+					&ao_offset);
+	if (ret) { /*new decoder*/
+		pr_err("remote: cant find match item for remote_ao_offset\n");
+		return -1;
+	}
+	/*ao_offset = P_AO_IR_DEC_LDR_ACTIVE;*/
+	/*ao_offset = P_AO_MF_IR_DEC_LDR_ACTIVE;*/
+	g_remote_ao_offset = ao_offset;
+	pr_info("remote: platform_data g_remote_ao_offset=%x\n", ao_offset);
+	/*get irq number.*/
+	res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	NEC_REMOTE_IRQ_NO = res_irq->start;
+	pr_info("remote: platform_data irq =%d\n", NEC_REMOTE_IRQ_NO);
+	remote_enable = 1;
+	remote = kzalloc(sizeof(struct remote), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!remote || !input_dev) {
+		kfree(remote);
+		input_free_device(input_dev);
+		return -ENOMEM;
+	}
+	gp_remote = remote;
+	remote->debug_enable = 1;
+	remote->ig_custom_enable = 1;
+	gp_remote->remote_send_key = remote_send_key;
+	input_dbg = remote_printk;
+	platform_set_drvdata(pdev, remote);
+	remote->map_num = 0;
+	remote->work_mode = remote->save_mode = DECODEMODE_NEC;
+	remote->input = input_dev;
+	remote->release_fdelay = KEY_RELEASE_DELAY;
+	remote->custom_code[remote->map_num] = 0xfb04;
+	for (i = 1; i < 20; i++)
+		remote->custom_code[i] = 0xffff;
+	remote->bit_count = 32;
+	remote->last_jiffies = 0xffffffff;
+	remote->last_pulse_width = 0;
+	remote->step = REMOTE_STATUS_WAIT;
+	remote->sleep = 0;
+	/*init logic0 logic1  time window*/
+	for (i = 0; i < 18; i++)
+		remote->time_window[i] = 0x1;
+	/* Disable the interrupt for the MPUIO keyboard
+	init the default key map table ,and mouse map table.
+	note KEY_RESERVED==0*/
+	memset(key_map, 0x00, sizeof(key_map));
+	memset(mouse_map, 0xff, sizeof(mouse_map));
+	remote->repeat_delay[remote->map_num]  = 250;
+	remote->repeat_peroid[remote->map_num]  = 33;
+	/* get the irq and init timer */
+	input_dbg("set drvdata completed\r\n");
+	tasklet_enable(&tasklet);
+	tasklet.data = (unsigned long)remote;
+	setup_timer(&remote->timer, remote_release_timer_sr, 0);
+	/*read status & frame register to abandon last key from uboot*/
+	am_remote_read_reg(DURATION_REG1_AND_STATUS);
+	am_remote_read_reg(FRAME_BODY);
+	/*reset IR decode*/
+	am_remote_write_reg(OPERATION_CTRL_REG1, 0x1f01);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING + 1;
+	early_suspend.suspend = remote_early_suspend;
+	early_suspend.resume = NULL;
+	early_suspend.param = gp_remote;
+	register_early_suspend(&early_suspend);
+#endif
+
+	ret = device_create_file(&pdev->dev, &dev_attr_enable);
+	if (ret < 0)
+		goto err1;
+	ret = device_create_file(&pdev->dev, &dev_attr_log_buffer);
+	if (ret < 0) {
+		device_remove_file(&pdev->dev, &dev_attr_enable);
+		goto err1;
+	}
+	ret = device_create_file(&pdev->dev, &dev_attr_powerkey);
+	if (ret < 0) {
+		device_remove_file(&pdev->dev, &dev_attr_enable);
+		device_remove_file(&pdev->dev, &dev_attr_log_buffer);
+		goto err1;
+	}
+
+	input_dbg("device_create_file completed \r\n");
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL)
+						| BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) |
+				BIT_MASK(BTN_RIGHT) | BIT_MASK(BTN_MIDDLE);
+	input_dev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y) | BIT_MASK
+						(REL_WHEEL);
+	input_dev->keybit[BIT_WORD(BTN_MOUSE)] |= BIT_MASK(BTN_SIDE)
+						| BIT_MASK(BTN_EXTRA);
+	for (i = 0; i < KEY_MAX; i++)
+		set_bit(i, input_dev->keybit);
+	input_dev->name = "aml_keypad";
+	input_dev->phys = "keypad/input0";
+	input_dev->dev.parent = &pdev->dev;
+	input_dev->id.bustype = BUS_ISA;
+	input_dev->id.vendor = 0x0001;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0100;
+	remote->repeat_enable = 0;
+	input_dev->rep[REP_DELAY] = 0xffffffff;
+	input_dev->rep[REP_PERIOD] = 0xffffffff;
+	input_dev->keycodesize = sizeof(unsigned short);
+	input_dev->keycodemax = 0x1ff;
+	ret = input_register_device(remote->input);
+	if (ret < 0) {
+		input_dbg("Unable to register keypad input device\n");
+		goto err2;
+	}
+	input_dbg("input_register_device completed \r\n");
+
+
+	if (hardware_init(pdev))
+		goto err3;
+	register_remote_dev(gp_remote);
+	remote_log_buf = (char *)__get_free_pages(GFP_KERNEL,
+					REMOTE_LOG_BUF_ORDER);
+	remote_log_buf[0] = '\0';
+	input_dbg("physical address:0x%x\n",
+		(unsigned int)virt_to_phys(remote_log_buf));
+	return 0;
+
+err3:
+	input_unregister_device(remote->input);
+	input_dev = NULL;
+err2:
+	device_remove_file(&pdev->dev, &dev_attr_enable);
+	device_remove_file(&pdev->dev, &dev_attr_log_buffer);
+err1:
+	kfree(remote);
+	input_free_device(input_dev);
+	return -EINVAL;
+}
+static int remote_remove(struct platform_device *pdev)
+{
+	struct remote *remote = platform_get_drvdata(pdev);
+	/* disable keypad interrupt handling */
+	input_dbg("remove remote\r\n");
+	tasklet_disable(&tasklet);
+	tasklet_kill(&tasklet);
+	/* unregister everything */
+	input_unregister_device(remote->input);
+	free_pages((unsigned long)remote_log_buf, REMOTE_LOG_BUF_ORDER);
+	device_remove_file(&pdev->dev, &dev_attr_enable);
+	device_remove_file(&pdev->dev, &dev_attr_log_buffer);
+	if (gp_remote->work_mode >= DECODEMODE_MAX) {
+#ifdef REMOTE_FIQ
+		free_fiq(NEC_REMOTE_IRQ_NO, remote_fiq_interrupt);
+		free_irq(BRIDGE_IRQ, gp_remote);
+#endif
+	} else
+		free_irq(NEC_REMOTE_IRQ_NO, remote_interrupt);
+	input_free_device(remote->input);
+
+	unregister_chrdev(remote->config_major, remote->config_name);
+	if (remote->config_class) {
+		if (remote->config_dev)
+			device_destroy(remote->config_class,
+			 MKDEV(remote->config_major, 0));
+		class_destroy(remote->config_class);
+	}
+
+	kfree(remote);
+	gp_remote = NULL;
+	return 0;
+}
+
+static int remote_resume(struct platform_device *pdev)
+{
+	struct remote *remote = platform_get_drvdata(pdev);
+	input_dbg("remote_resume To do remote resume\n");
+	input_dbg("remote_resume make sure read frame enable ir interrupt\n");
+	am_remote_read_reg(DURATION_REG1_AND_STATUS);
+	am_remote_read_reg(FRAME_BODY);
+	remote_restore_regs(remote->work_mode); /*restore remote regs*/
+    //TODO(rgerganov): missing API in 4.9
+	//if (is_meson_m8m2_cpu()) {
+	if (0) {
+#define  AO_RTI_STATUS_REG2 ((0x00 << 10) | (0x02 << 2))
+		if (aml_read_aobus(AO_RTI_STATUS_REG2) == 0x1234abcd) {
+			/*aml_write_reg32(P_AO_RTC_ADDR0,
+			(aml_read_reg32(P_AO_RTC_ADDR0) | (0x0000f000)));*/
+			aml_write_aobus(AO_RTI_STATUS_REG2, 0);
+		}
+	} else {
+		if (get_resume_method() == REMOTE_WAKEUP) {
+			input_dbg("remote_wakeup\n");
+		}
+		if (get_resume_method() == ETH_PHY_WAKEUP) {
+			input_dbg("ethernet_wakeup\n");
+			input_event(gp_remote->input, EV_KEY, KEY_POWER, 1);
+			input_sync(gp_remote->input);
+			input_event(gp_remote->input, EV_KEY, KEY_POWER, 0);
+			input_sync(gp_remote->input);
+		}
+	}
+
+	gp_remote->sleep = 0;
+	input_dbg("to clear irq ...\n");
+	disable_irq(NEC_REMOTE_IRQ_NO);
+	udelay(1000);
+	enable_irq(NEC_REMOTE_IRQ_NO);
+
+	return 0;
+}
+
+static int remote_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct remote *remote = platform_get_drvdata(pdev);
+	input_dbg("remote_suspend, set sleep 1\n");
+	remote_save_regs(remote->work_mode); /*save remote regs*/
+	gp_remote->sleep = 1;
+	return 0;
+}
+
+
+static struct platform_driver remote_driver = {
+	.probe = remote_probe,
+	.remove = remote_remove,
+	.suspend = remote_suspend,
+	.resume = remote_resume,
+	.driver = {
+		.name = "meson-remote",
+		.of_match_table = remote_dt_match,
+	},
+};
+
+static int __init remote_init(void)
+{
+	pr_info("remote: Driver init\n");
+	return platform_driver_register(&remote_driver);
+}
+
+static void __exit remote_exit(void)
+{
+	input_dbg("remote: exit\n");
+	platform_driver_unregister(&remote_driver);
+}
+
+module_init(remote_init);
+module_exit(remote_exit);
+
+MODULE_AUTHOR("Beijing-platform");
+MODULE_DESCRIPTION("Remote Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/input/remote/remote_main.h b/drivers/amlogic/input/remote/remote_main.h
new file mode 100644
index 000000000000..fe6e9d175af3
--- /dev/null
+++ b/drivers/amlogic/input/remote/remote_main.h
@@ -0,0 +1,668 @@
+#ifndef _REMOTE_H
+#define _REMOTE_H
+#include <asm/ioctl.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/io.h>
+#include <linux/amlogic/iomap.h>
+#ifdef REMOTE_FIQ
+#include <plat/fiq_bridge.h>
+#endif
+
+/*suspend relative ao register*/
+
+/*remote register*/
+#define LDR_ACTIVE 0x0
+#define LDR_IDLE 0x1
+#define LDR_REPEAT 0x2
+#define DURATION_REG0    0x3
+#define OPERATION_CTRL_REG0 0x4
+#define FRAME_BODY 0x5
+#define DURATION_REG1_AND_STATUS 0x6
+#define OPERATION_CTRL_REG1 0x7
+#define OPERATION_CTRL_REG2 0x8
+#define DURATION_REG2    0x9
+#define DURATION_REG3    0xa
+#define FRAME_BODY1 0xb
+#define OPERATION_CTRL_REG3 0xe
+#define CONFIG_END 0xff
+/*config remote register val*/
+struct reg_s {
+	int reg;
+	unsigned int val;
+};
+enum {
+	NORMAL = 0,
+	TIMER = 1 ,
+};
+
+/*
+   Decode_mode.(format selection)
+   0x0 =NEC
+   0x1= skip leader (just bits)
+   0x2=measure width (software decode)
+   0x3=MITSUBISHI
+   0x4=Thomson
+   0x5=Toshiba
+   0x6=Sony SIRC
+   0x7=RC5
+   0x8=Reserved
+   0x9=RC6
+   0xA=RCMM
+   0xB=Duokan
+   0xC=Reserved
+   0xD=Reserved
+   0xE=Comcast
+   0xF=Sanyo
+ */
+enum {
+	DECODEMODE_NEC = 0,
+	DECODEMODE_DUOKAN = 1 ,
+	DECODEMODE_RCMM ,
+	DECODEMODE_SONYSIRC,
+	DECODEMODE_SKIPLEADER ,
+	DECODEMODE_MITSUBISHI,
+	DECODEMODE_THOMSON,
+	DECODEMODE_TOSHIBA,
+	DECODEMODE_RC5,
+	DECODEMODE_RESERVED,
+	DECODEMODE_RC6,
+	DECODEMODE_RCA,
+	DECODEMODE_COMCAST,
+	DECODEMODE_SANYO,
+	DECODEMODE_NEC_RCA_2IN1 = 14,
+	DECODEMODE_NEC_TOSHIBA_2IN1 = 15,
+	DECODEMODE_NEC_RCMM_2IN1,
+	DECODEMODE_SW,
+	DECODEMODE_MAX ,
+	DECODEMODE_SW_NEC,
+	DECODEMODE_SW_DUOKAN
+
+};
+
+/*remote config val*/
+/****************************************************************/
+static const struct reg_s RDECODEMODE_NEC[] = {
+	{LDR_ACTIVE, ((unsigned)500 << 16) | ((unsigned)400 << 0)},
+	/* NEC leader 9500us,max 477:
+	(477* timebase = 20) = 9540 ;min 400 = 8000us*/
+	{LDR_IDLE, 300 << 16 | 200 << 0}, /* leader idle*/
+	{LDR_REPEAT, 150 << 16 | 80 << 0}, /* leader repeat*/
+	{DURATION_REG0, 72 << 16 | 40 << 0 }, /* logic '0' or '00'*/
+	{OPERATION_CTRL_REG0, 7 << 28 | (0xFA0 << 12) | 0x13},
+	/* sys clock boby time.base time = 20 body frame 108ms*/
+	{DURATION_REG1_AND_STATUS, (134 << 20) | (90 << 10)},
+	/* logic '1' or '01'*/
+	{OPERATION_CTRL_REG1, 0x9f00}, /* boby long decode (8-13)*/
+	/*{OPERATION_CTRL_REG1,0xbe40},// boby long decode (8-13)*/
+	{OPERATION_CTRL_REG2, 0x0}, /* hard decode mode*/
+	{DURATION_REG2, 0},
+	{DURATION_REG3, 0},
+	{CONFIG_END,            0      }
+};
+/****************************************************************/
+static const struct reg_s RDECODEMODE_DUOKAN[] = {
+	{LDR_ACTIVE, ((70 << 16) | (30 << 0))},
+	{LDR_IDLE, ((50 << 16) | (15 << 0))},
+	{LDR_REPEAT, ((30 << 16) | (26 << 0))},
+	{DURATION_REG0, ((66 << 16) | (40 << 0))},
+	{OPERATION_CTRL_REG0, ((3 << 28) | (0x4e2 << 12) | (0x13))},
+	/*logic '00' max=66*20us ,min=40*20us  */
+	/*body frame 30ms*/
+	{DURATION_REG1_AND_STATUS, ((80 << 20) | (66 << 10))},
+	/*logic '01' max=80*20us,min=66*20us */
+	{OPERATION_CTRL_REG1, 0x9300},
+	{OPERATION_CTRL_REG2, 0xb90b},
+	{DURATION_REG2, ((97 << 16) | (80 << 0))},
+	/*logic '10' max=97*20us,min=80*20us */
+	{DURATION_REG3, ((120 << 16) | (97 << 0))},
+	/*logic '11' max=120*20us,min=97*20us */
+	{OPERATION_CTRL_REG3, 5000<<0},
+	{CONFIG_END,            0      }
+};
+/****************************************************************/
+static const struct reg_s RDECODEMODE_RCMM[] = {
+	{LDR_ACTIVE, 25 << 16 | 22 << 0},
+	{LDR_IDLE, 14 << 16 | 13 << 0},
+	{LDR_REPEAT, 14 << 16 | 13 << 0},
+	{DURATION_REG0, 25 << 16 | 21 << 0 },
+	{OPERATION_CTRL_REG0, 3 << 28 | (0x708 << 12) | 0x13},
+	/* body frame 28 or 36 ms*/
+	{DURATION_REG1_AND_STATUS, 33 << 20 | 29 << 10},
+	{OPERATION_CTRL_REG1, 0xbe40},
+	{OPERATION_CTRL_REG2, 0xa},
+	{DURATION_REG2, 39 << 16 | 36 << 0},
+	{DURATION_REG3, 50 << 16 | 46 << 0},
+	{CONFIG_END,            0      }
+};
+/****************************************************************/
+static const struct reg_s RDECODEMODE_SONYSIRC[] = {
+	{LDR_ACTIVE, 130 << 16 | 110 << 0},
+	{LDR_IDLE, 33 << 16 | 27 << 0},
+	{LDR_REPEAT, 33 << 16 | 27 << 0},
+	{DURATION_REG0, 63 << 16 | 56 << 0 },
+	{OPERATION_CTRL_REG0, 3 << 28 | (0x8ca << 12) | 0x13},
+	/* body frame 45ms*/
+	{DURATION_REG1_AND_STATUS, 94 << 20 | 82 << 10},
+	{OPERATION_CTRL_REG1, 0xbe40},
+	{OPERATION_CTRL_REG2, 0x6},
+	{DURATION_REG2, 0},
+	{DURATION_REG3, 0},
+	{CONFIG_END,            0      }
+};
+
+/**************************************************************/
+
+static const struct reg_s RDECODEMODE_MITSUBISHI[] = {
+	{LDR_ACTIVE, 410 << 16 | 390 << 0},
+	{LDR_IDLE, 225 << 16 | 200 << 0},
+	{LDR_REPEAT, 225 << 16 | 200 << 0},
+	{DURATION_REG0, 60 << 16 | 48 << 0 },
+	{OPERATION_CTRL_REG0, 3 << 28 | (0xBB8 << 12) | 0x13},
+	/*An IR command is repeated 60ms for as long as the key
+	on the remote is held down. body frame 60ms*/
+	{DURATION_REG1_AND_STATUS, 110 << 20 | 95 << 10},
+	{OPERATION_CTRL_REG1, 0xbe40},
+	{OPERATION_CTRL_REG2, 0x3},
+	{DURATION_REG2, 0},
+	{DURATION_REG3, 0},
+	{CONFIG_END,            0      }
+
+};
+/**********************************************************/
+static const struct reg_s RDECODEMODE_TOSHIBA[] = {
+	{LDR_ACTIVE, 477 << 16 | 389 << 0}, /*TOSHIBA leader 9000us*/
+	{LDR_IDLE, 477 << 16 | 389 << 0}, /* leader idle*/
+	{LDR_REPEAT, 460 << 16 | 389 << 0}, /* leader repeat*/
+	{DURATION_REG0, 60 << 16 | 40 << 0 }, /* logic '0' or '00'*/
+	{OPERATION_CTRL_REG0, 3 << 28 | (0xFA0 << 12) | 0x13},
+	{DURATION_REG1_AND_STATUS, 111 << 20 | 100 << 10},
+	/* logic '1' or '01'*/
+	{OPERATION_CTRL_REG1, 0xbe40}, /* boby long decode (8-13)*/
+	{OPERATION_CTRL_REG2, 0x5}, /* hard decode mode*/
+	{DURATION_REG2, 0},
+	{DURATION_REG3, 0},
+	{CONFIG_END,            0      }
+
+};
+/*****************************************************************/
+static const struct reg_s RDECODEMODE_THOMSON[] = {
+	{LDR_ACTIVE, 477 << 16 | 390 << 0}, /* THOMSON leader 8000us,*/
+	{LDR_IDLE, 477 << 16 | 390 << 0}, /* leader idle*/
+	{LDR_REPEAT, 460 << 16 | 390 << 0}, /* leader repeat*/
+	{DURATION_REG0, 80 << 16 | 60 << 0 }, /* logic '0' or '00'*/
+	{OPERATION_CTRL_REG0, 3 << 28 | (0xFA0 << 12) | 0x13},
+	{DURATION_REG1_AND_STATUS, 140 << 20 | 120 << 10},
+	/* logic '1' or '01'*/
+	{OPERATION_CTRL_REG1, 0xbe40}, /* boby long decode (8-13)*/
+	{OPERATION_CTRL_REG2, 0x4}, /* hard decode mode*/
+	{DURATION_REG2, 0},
+	{DURATION_REG3, 0},
+	{CONFIG_END,            0      }
+};
+/*********************************************************************/
+static const struct reg_s RDECODEMODE_COMCAST[] = {
+	{LDR_ACTIVE, 0   },
+	{LDR_IDLE, 0  },
+	{LDR_REPEAT, 0   },
+	{DURATION_REG0, 0},
+	{OPERATION_CTRL_REG0, 0},
+	{DURATION_REG1_AND_STATUS,},
+	{OPERATION_CTRL_REG1,},
+	{OPERATION_CTRL_REG2,},
+	{DURATION_REG2,},
+	{DURATION_REG3,},
+	{CONFIG_END,            0      }
+};
+static const struct reg_s RDECODEMODE_SKIPLEADER[] = {
+	{LDR_ACTIVE,    },
+	{LDR_IDLE,     },
+	{LDR_REPEAT,    },
+	{DURATION_REG0, },
+	{OPERATION_CTRL_REG0,},
+	{DURATION_REG1_AND_STATUS,},
+	{OPERATION_CTRL_REG1,},
+	{OPERATION_CTRL_REG2,},
+	{DURATION_REG2,},
+	{DURATION_REG3,},
+	{CONFIG_END,            0      }
+};
+static const struct reg_s RDECODEMODE_SW[] = {
+	{LDR_ACTIVE,    },
+	{LDR_IDLE,     },
+	{LDR_REPEAT,    },
+	{DURATION_REG0, },
+	{OPERATION_CTRL_REG0,},
+	{DURATION_REG1_AND_STATUS,},
+	{OPERATION_CTRL_REG1,},
+	{OPERATION_CTRL_REG2,},
+	{DURATION_REG2,},
+	{DURATION_REG3,},
+	{CONFIG_END,            0      }
+};
+static const struct reg_s RDECODEMODE_SW_NEC[] = {
+	{LDR_ACTIVE, ((unsigned)477 << 16) | ((unsigned)400 << 0)},
+	/* NEC leader 9500us,max 477:
+	(477* timebase = 20) = 9540 ;min 400 = 8000us*/
+	{LDR_IDLE, 248 << 16 | 202 << 0},
+	/* leader idle*/
+	{LDR_REPEAT, 130 << 16 | 110 << 0},
+	/* leader repeat*/
+	{DURATION_REG0, 60 << 16 | 48 << 0 },
+	/* logic '0' or '00'*/
+	{OPERATION_CTRL_REG0, 3 << 28 | (0xFA0 << 12) | 0x13},
+	/* sys clock boby time.base time = 20 body frame 108ms*/
+	{DURATION_REG1_AND_STATUS, (111 << 20) | (100 << 10)},
+	/* logic '1' or '01'*/
+	{OPERATION_CTRL_REG1, 0x8578}, /* boby long decode (8-13)*/
+	{OPERATION_CTRL_REG2, 0x2}, /**/
+	{DURATION_REG2, 0},
+	{DURATION_REG3, 0},
+	{CONFIG_END,            0      }
+};
+static const struct reg_s RDECODEMODE_SW_DUOKAN[] = {
+	{LDR_ACTIVE, 52 << 16 | 49 << 0},
+	{LDR_IDLE, 30 << 16 | 26 << 0},
+	{LDR_REPEAT, 30 << 16 | 26 << 0},
+	{DURATION_REG0, 60 << 16 | 56 << 0 },
+	{OPERATION_CTRL_REG0, 3 << 28 | (0x5DC << 12) | 0x13},
+	/*body frame 30ms*/
+	{DURATION_REG1_AND_STATUS, (75 << 20) | 70 << 10},
+	/* logic '1' or '01'*/
+	{OPERATION_CTRL_REG1, 0x8578}, /* boby long decode (8-13)*/
+	{OPERATION_CTRL_REG2, 0x2}, /* sw_duokan*/
+	{DURATION_REG2, 0},
+	{DURATION_REG3, 0},
+	{CONFIG_END,            0      }
+};
+static const struct reg_s RDECODEMODE_NEC_RCA_2IN1[] = {
+	/* used old decode*/
+	{LDR_ACTIVE - 0x40, ((unsigned)477 << 16) | ((unsigned)400 << 0)},
+	/* NEC leader 9500us,max 477:
+	(477* timebase = 20) = 9540 ;min 400 = 8000us*/
+	{LDR_IDLE - 0x40, 248 << 16 | 202 << 0}, /* leader idle*/
+	{LDR_REPEAT - 0x40, 130 << 16 | 110 << 0}, /* leader repeat*/
+	{DURATION_REG0 - 0x40, 60 << 16 | 48 << 0 }, /* logic '0' or '00'*/
+	{OPERATION_CTRL_REG0 - 0x40, 3 << 28 | (0xFA0 << 12) | 0x13},
+	/* sys clock boby time.base time = 20 body frame 108ms*/
+	{DURATION_REG1_AND_STATUS - 0x40, (111 << 20) | (100 << 10)},
+	/* logic '1' or '01'*/
+	{OPERATION_CTRL_REG1 - 0x40, 0xbe40}, /* boby long decode (9-13)*/
+	/* used new decode*/
+	{LDR_ACTIVE, ((unsigned)250 << 16) | ((unsigned)160 << 0)},
+	/*rca leader 4000us,200* timebase*/
+	{LDR_IDLE, 250 << 16 | 160 << 0}, /* leader idle 400*/
+	{LDR_REPEAT, 250 << 16 | 160 << 0}, /* leader repeat*/
+	{DURATION_REG0, 100 << 16 | 48 << 0 }, /* logic '0' or '00' 1500us*/
+	{OPERATION_CTRL_REG0, 3 << 28 | (0xFA0 << 12) | 0x13},
+	/* sys clock boby time.base time = 20 body frame*/
+	{DURATION_REG1_AND_STATUS, (150 << 20) | (110 << 10)},
+	/* logic '1' or '01'     2500us*/
+	{OPERATION_CTRL_REG1, 0x9740},
+	/* boby long decode (8-13) //framn len = 24bit*/
+	/*it may get the wrong customer value and key value from register if
+	the value is set to 0x4,so the register value must set to 0x104*/
+	{OPERATION_CTRL_REG2, 0x104},
+	{DURATION_REG2, 0},
+	{DURATION_REG3, 0},
+	{CONFIG_END,            0      }
+};
+static const struct reg_s RDECODEMODE_NEC_TOSHIBA_2IN1[] = {
+	/* used old decode*/
+	{LDR_ACTIVE - 0x40, ((unsigned)500 << 16) | ((unsigned)400 << 0)},
+	/* NEC leader 9500us,max 477:
+	(477* timebase = 20) = 9540 ;min 400 = 8000us*/
+	{LDR_IDLE - 0x40, 300 << 16 | 200 << 0},
+	/* leader idle*/
+	{LDR_REPEAT - 0x40, 150 << 16 | 80 << 0},
+	/* leader repeat*/
+	{DURATION_REG0 - 0x40, 72 << 16 | 40 << 0 },
+	/* logic '0' or '00'*/
+	{OPERATION_CTRL_REG0 - 0x40, 3 << 28 | (0xFA0 << 12) | 0x13},
+	/* sys clock boby time.base time = 20 body frame 108ms*/
+	{DURATION_REG1_AND_STATUS - 0x40, (134 << 20) | (90 << 10)},
+	/* logic '1' or '01'*/
+	{OPERATION_CTRL_REG1 - 0x40, 0xbe10},
+	/* boby long decode (9-13)*/
+	/* used new decode*/
+	{LDR_ACTIVE, ((unsigned)300 << 16) | ((unsigned)160 << 0)},
+	/*toshiba leader 4500us,20* timebase*/
+	{LDR_IDLE, 300 << 16 | 160 << 0},
+	/* leader idle 4500*/
+	{LDR_REPEAT, 300 << 16 | 160 << 0},
+	/* leader repeat*/
+	{DURATION_REG0, 90 << 16 | 48 << 0 },
+	/* logic '0' or '00' 1200us*/
+	{OPERATION_CTRL_REG0, 3 << 28 | (0xFA0 << 12) | 0x13},
+	/* sys clock boby time.base time = 20 body frame*/
+	{DURATION_REG1_AND_STATUS, (150 << 20) | (100 << 10)},
+	/* logic '1' or '01'     2400us*/
+	{OPERATION_CTRL_REG1, 0x9f40},
+	/* boby long decode (8-13) framn len = 24bit*/
+	{OPERATION_CTRL_REG2, 0x5},
+	{DURATION_REG2, 0},
+	{DURATION_REG3, 0},
+	{CONFIG_END,            0      }
+};
+static const struct reg_s RDECODEMODE_NEC_RCMM_2IN1[] = {
+	/*used old decode*/
+	{LDR_ACTIVE-0x40, ((unsigned)477<<16) | ((unsigned)400<<0)},/*leader*/
+	{LDR_IDLE-0x40, 248<<16 | 202<<0},/*leader idle*/
+	{LDR_REPEAT-0x40, 130<<16|110<<0}, /* leader repeat*/
+	{DURATION_REG0-0x40, 60<<16|48<<0 },/*logic '0' or '00'*/
+	{OPERATION_CTRL_REG0-0x40, 3<<28|(0xFA0<<12)|0x13}, /*base time = 20*/
+	{DURATION_REG1_AND_STATUS-0x40, (111<<20)|(100<<10)},/*logic '1'or'01'*/
+	{OPERATION_CTRL_REG1-0x40, 0xbe00},/*boby long decode (9-13)*/
+	/*used new decode*/
+	{LDR_ACTIVE, ((unsigned)35<<16) | ((unsigned)17<<0)},/*leader active*/
+	{LDR_IDLE, 17<<16 | 8<<0},/*leader idle*/
+	{LDR_REPEAT, 31<<16 | 11<<0},  /*leader repeat*/
+	{DURATION_REG0, 25<<16|21<<0 },/*logic '0' or '00' 1200us*/
+	{OPERATION_CTRL_REG0, 3<<28|(590<<12)|0x13},  /*time.base time = 20*/
+	{DURATION_REG1_AND_STATUS, (33<<20)|(29<<10)},/*logic '1' or '01'*/
+	{OPERATION_CTRL_REG1, 0x9f00},/*boby long decode (8-13)*/
+	{OPERATION_CTRL_REG2, 0x1150a},
+	{DURATION_REG2, 41<<16 | 36<<0},
+	{DURATION_REG3, 50<<16 | 44<<0},
+	{OPERATION_CTRL_REG3, 1200<<0},
+	{CONFIG_END,            0      }
+};
+
+static const struct reg_s RDECODEMODE_RC5[] = {
+	{LDR_ACTIVE,    },
+	{LDR_IDLE,     },
+	{LDR_REPEAT,    },
+	{DURATION_REG0, },
+	{OPERATION_CTRL_REG0,},
+	{DURATION_REG1_AND_STATUS,},
+	{OPERATION_CTRL_REG1,},
+	{OPERATION_CTRL_REG2,},
+	{DURATION_REG2,},
+	{DURATION_REG3,},
+	{CONFIG_END,            0      }
+};
+static const struct reg_s RDECODEMODE_RESERVED[] = {
+	{LDR_ACTIVE,    },
+	{LDR_IDLE,     },
+	{LDR_REPEAT,    },
+	{DURATION_REG0, },
+	{OPERATION_CTRL_REG0,},
+	{DURATION_REG1_AND_STATUS,},
+	{OPERATION_CTRL_REG1,},
+	{OPERATION_CTRL_REG2,},
+	{DURATION_REG2,},
+	{DURATION_REG3,},
+	{CONFIG_END,            0      }
+};
+static const struct reg_s RDECODEMODE_RC6[] = {
+	{LDR_ACTIVE, ((unsigned)210 << 16) | ((unsigned)125 << 0)},
+	/*rca leader 4000us,200* timebase*/
+	{LDR_IDLE, 50 << 16 | 38 << 0}, /* leader idle 400*/
+	{LDR_REPEAT, 145 << 16 | 125 << 0}, /* leader repeat*/
+	{DURATION_REG0, 51 << 16 | 38 << 0 }, /* logic '0' or '00' 1500us*/
+	{OPERATION_CTRL_REG0, (3 << 28)|(0xFA0 << 12)|0x13},
+	/* sys clock boby time.base time = 20 body frame*/
+	{DURATION_REG1_AND_STATUS, (94 << 20) | (82 << 10)},
+	/* logic '1' or '01'     2500us*/
+	{OPERATION_CTRL_REG1, 0xa440},/*20bit 9440  36bit a340 32bit 9f40*/
+	/* boby long decode (8-13) //framn len = 24bit*/
+	/*it may get the wrong customer value and key value from register if
+	the value is set to 0x4,so the register value must set to 0x104*/
+	{OPERATION_CTRL_REG2, 0x109},
+	{DURATION_REG2, ((28 << 16) | (16 << 0))},
+	{DURATION_REG3, ((51 << 16) | (38 << 0))},
+	{CONFIG_END,            0      }
+};
+
+
+
+static const struct reg_s RDECODEMODE_SANYO[] = {
+	{LDR_ACTIVE,    },
+	{LDR_IDLE,     },
+	{LDR_REPEAT,    },
+	{DURATION_REG0, },
+	{OPERATION_CTRL_REG0,},
+	{DURATION_REG1_AND_STATUS,},
+	{OPERATION_CTRL_REG1,},
+	{OPERATION_CTRL_REG2,},
+	{DURATION_REG2,},
+	{DURATION_REG3,},
+	{CONFIG_END,            0      }
+};
+
+
+
+extern char *remote_log_buf;
+extern unsigned long g_remote_ao_offset;
+
+#ifdef CONFIG_AML_HDMI_TX
+extern int cec_power_flag;
+extern int rc_long_press_pwr_key;
+#endif
+
+#define am_remote_write_reg(x, val) (aml_write_aobus \
+	((g_remote_ao_offset+((x)<<2)), val))
+
+#define am_remote_read_reg(x) (aml_read_aobus \
+	(g_remote_ao_offset+((x)<<2)))
+
+#define am_remote_set_mask(x, val) (aml_write_aobus \
+	((g_remote_ao_offset+((x)<<2)), (am_remote_read_reg(x)|(val))))
+
+#define am_remote_clear_mask(x, val) (aml_write_aobus \
+	((g_remote_ao_offset+((x)<<2)), (am_remote_read_reg(x)&(~(val)))))
+void setremotereg(const struct reg_s *r);
+
+
+/*remote config  ioctl  cmd*/
+#define REMOTE_IOC_INFCODE_CONFIG       _IOW('I', 13, u32)
+#define REMOTE_IOC_RESET_KEY_MAPPING        _IOW('I', 3, u32)
+#define REMOTE_IOC_SET_KEY_MAPPING          _IOW('I', 4, u32)
+#define REMOTE_IOC_SET_REPEAT_KEY_MAPPING   _IOW('I', 20, u32)
+#define REMOTE_IOC_SET_MOUSE_MAPPING        _IOW('I', 5, u32)
+#define REMOTE_IOC_SET_REPEAT_DELAY         _IOW('I', 6, u32)
+#define REMOTE_IOC_SET_REPEAT_PERIOD        _IOW('I', 7, u32)
+
+#define REMOTE_IOC_SET_REPEAT_ENABLE        _IOW('I', 8, u32)
+#define REMOTE_IOC_SET_DEBUG_ENABLE         _IOW('I', 9, u32)
+#define REMOTE_IOC_SET_MODE                 _IOW('I', 10, u32)
+
+#define REMOTE_IOC_SET_CUSTOMCODE       _IOW('I', 100, u32)
+#define REMOTE_IOC_SET_RELEASE_DELAY        _IOW('I', 99, u32)
+
+/*reg*/
+#define REMOTE_IOC_SET_REG_BASE_GEN         _IOW('I', 101, u32)
+#define REMOTE_IOC_SET_REG_CONTROL          _IOW('I', 102, u32)
+#define REMOTE_IOC_SET_REG_LEADER_ACT       _IOW('I', 103, u32)
+#define REMOTE_IOC_SET_REG_LEADER_IDLE      _IOW('I', 104, u32)
+#define REMOTE_IOC_SET_REG_REPEAT_LEADER    _IOW('I', 105, u32)
+#define REMOTE_IOC_SET_REG_BIT0_TIME         _IOW('I', 106, u32)
+
+/*sw*/
+#define REMOTE_IOC_SET_BIT_COUNT            _IOW('I', 107, u32)
+#define REMOTE_IOC_SET_TW_LEADER_ACT        _IOW('I', 108, u32)
+#define REMOTE_IOC_SET_TW_BIT0_TIME         _IOW('I', 109, u32)
+#define REMOTE_IOC_SET_TW_BIT1_TIME         _IOW('I', 110, u32)
+#define REMOTE_IOC_SET_TW_REPEATE_LEADER    _IOW('I', 111, u32)
+
+#define REMOTE_IOC_GET_TW_LEADER_ACT        _IOR('I', 112, u32)
+#define REMOTE_IOC_GET_TW_BIT0_TIME         _IOR('I', 113, u32)
+#define REMOTE_IOC_GET_TW_BIT1_TIME         _IOR('I', 114, u32)
+#define REMOTE_IOC_GET_TW_REPEATE_LEADER    _IOR('I', 115, u32)
+
+#define REMOTE_IOC_GET_REG_BASE_GEN         _IOR('I', 121, u32)
+#define REMOTE_IOC_GET_REG_CONTROL          _IOR('I', 122, u32)
+#define REMOTE_IOC_GET_REG_LEADER_ACT       _IOR('I', 123, u32)
+#define REMOTE_IOC_GET_REG_LEADER_IDLE      _IOR('I', 124, u32)
+#define REMOTE_IOC_GET_REG_REPEAT_LEADER    _IOR('I', 125, u32)
+#define REMOTE_IOC_GET_REG_BIT0_TIME        _IOR('I', 126, u32)
+#define REMOTE_IOC_GET_REG_FRAME_DATA       _IOR('I', 127, u32)
+#define REMOTE_IOC_GET_REG_FRAME_STATUS     _IOR('I', 128, u32)
+
+#define REMOTE_IOC_SET_TW_BIT2_TIME         _IOW('I', 129, u32)
+#define REMOTE_IOC_SET_TW_BIT3_TIME         _IOW('I', 130, u32)
+
+#define   REMOTE_IOC_SET_FN_KEY_SCANCODE     _IOW('I', 131, u32)
+#define   REMOTE_IOC_SET_LEFT_KEY_SCANCODE   _IOW('I', 132, u32)
+#define   REMOTE_IOC_SET_RIGHT_KEY_SCANCODE  _IOW('I', 133, u32)
+#define   REMOTE_IOC_SET_UP_KEY_SCANCODE     _IOW('I', 134, u32)
+#define   REMOTE_IOC_SET_DOWN_KEY_SCANCODE   _IOW('I', 135, u32)
+#define   REMOTE_IOC_SET_OK_KEY_SCANCODE     _IOW('I', 136, u32)
+#define   REMOTE_IOC_SET_PAGEUP_KEY_SCANCODE _IOW('I', 137, u32)
+#define REMOTE_IOC_SET_PAGEDOWN_KEY_SCANCODE _IOW('I', 138, u32)
+#define   REMOTE_IOC_SET_RELT_DELAY     _IOW('I', 140, u32)
+
+#define   REMOTE_IOC_GET_POWERKEY			 _IOR('I', 141, u32)
+
+#define REMOTE_HW_DECODER_STATUS_MASK       (0xf<<4)
+#define REMOTE_HW_DECODER_STATUS_OK         (0<<4)
+#define REMOTE_HW_DECODER_STATUS_TIMEOUT    (1<<4)
+#define REMOTE_HW_DECODER_STATUS_LEADERERR  (2<<4)
+#define REMOTE_HW_DECODER_STATUS_REPEATERR  (3<<4)
+
+/* software  decode status*/
+#define REMOTE_STATUS_WAIT       0
+#define REMOTE_STATUS_LEADER     1
+#define REMOTE_STATUS_DATA       2
+#define REMOTE_STATUS_SYNC       3
+
+#define REPEARTFLAG 0x1
+/*status register repeat set flag*/
+#define KEYDOMIAN 1
+/* find key val vail data domain*/
+#define CUSTOMDOMAIN 0
+/* find key val vail custom domain*/
+/*phy page user debug*/
+#define REMOTE_LOG_BUF_LEN       4098
+#define REMOTE_LOG_BUF_ORDER        1
+
+
+enum rc_key_state {
+	RC_KEY_STATE_UP = 0,
+	RC_KEY_STATE_DN = 1,
+};
+
+typedef int (*type_printk)(const char *fmt, ...);
+/* this is a message of IR input device,include release timer repeat timer*/
+/*
+ */
+struct remote {
+	struct input_dev *input;
+	struct timer_list timer;
+	/*release timer*/
+	struct timer_list repeat_timer;
+	/*repeat timer*/
+	struct timer_list rel_timer;
+	/*repeat timer*/
+	unsigned long repeat_tick;
+	int irq;
+	int save_mode;
+	int work_mode;
+	/* use ioctl config decode mode*/
+	int temp_work_mode;
+	/* use ioctl config decode mode*/
+	int frame_mode;
+	/* same protocol frame have diffrent mode*/
+	unsigned int register_data;
+	unsigned int frame_status;
+	unsigned int cur_keycode;
+	unsigned int cur_lsbkeycode;
+	/* rcv low 32bit save*/
+	unsigned int cur_msbkeycode;
+	/* rcv high 10bit save*/
+	unsigned int repeat_release_code;
+	/* save*/
+	unsigned int last_keycode;
+	unsigned int repeate_flag;
+	unsigned int repeat_enable;
+	unsigned int debounce;
+	unsigned int status;
+	/* we can only support 20 maptable*/
+	int map_num;
+	int ig_custom_enable;
+	int enable_repeat_falg;
+	unsigned int custom_code[20];
+	/*use duble protocol release time*/
+	/*frist protocol*/
+	unsigned int release_fdelay;
+	/* second protocol*/
+	unsigned int release_sdelay;
+	unsigned int release_delay[20];
+	/*debug swtich*/
+	unsigned int debug_enable;
+	/*sw*/
+	unsigned int sleep;
+	unsigned int delay;
+	unsigned int step;
+	unsigned int send_data;
+
+	/* 0:up(default) 1:down */
+	unsigned int keystate;
+	/* store irq time */
+	unsigned long jiffies_irq;
+	unsigned long jiffies_old;
+	unsigned long jiffies_new;
+
+#ifdef REMOTE_FIQ
+	bridge_item_t fiq_handle_item;
+#endif
+	int want_repeat_enable;
+	unsigned int key_repeat_map[20][256];
+	unsigned int bit_count;
+	unsigned int bit_num;
+	unsigned int last_jiffies;
+	unsigned int time_window[18];
+	int last_pulse_width;
+	int repeat_time_count;
+	/*config*/
+	int config_major;
+	char config_name[20];
+	struct class *config_class;
+	struct device *config_dev;
+	unsigned int repeat_delay[20];
+	unsigned int relt_delay[20];
+	unsigned int repeat_peroid[20];
+	int (*remote_reprot_press_key)(struct remote *);
+	int (*key_report)(struct remote *);
+	void (*key_release_report)(struct remote *);
+	void (*remote_send_key)(struct input_dev *,
+		unsigned int, unsigned int, int);
+};
+
+extern type_printk input_dbg;
+
+int set_remote_mode(int mode);
+void set_remote_init(struct remote *remote_data);
+void kdb_send_key(struct input_dev *dev, unsigned int scancode,
+		  unsigned int type, int event);
+void remote_send_key(struct input_dev *dev, unsigned int scancode,
+		     unsigned int type, int event);
+extern irqreturn_t remote_bridge_isr(int irq, void *dev_id);
+extern irqreturn_t remote_null_bridge_isr(int irq, void *dev_id);
+extern int remote_hw_report_null_key(struct remote *remote_data);
+extern int remote_hw_report_key(struct remote *remote_data);
+extern int remote_duokan_report_key(struct remote *remote_data);
+extern int remote_rc6_report_key(struct remote *remote_data);
+extern int remote_hw_nec_rca_2in1_report_key(struct remote *remote_data);
+extern int remote_hw_nec_toshiba_2in1_report_key(struct remote *remote_data);
+extern int remote_hw_nec_rcmm_2in1_report_key(struct remote *remote_data);
+extern int remote_sw_report_key(struct remote *remote_data);
+extern void remote_nec_report_release_key(struct remote *remote_data);
+extern void remote_nec_rca_2in1_report_release_key(struct remote *remote_data);
+extern void remote_nec_toshiba_2in1_report_release_key(struct remote
+		*remote_data);
+extern void remote_nec_rcmm_2in1_report_release_key(struct remote *remote_data);
+extern void remote_duokan_report_release_key(struct remote *remote_data);
+extern void remote_rc6_report_release_key(struct remote *remote_data);
+extern void remote_sw_report_release_key(struct remote *remote_data);
+extern void remote_null_report_release_key(struct remote *remote_data);
+#ifdef REMOTE_FIQ
+extern int register_fiq_bridge_handle(bridge_item_t *c_item);
+extern int unregister_fiq_bridge_handle(bridge_item_t *c_item);
+extern int fiq_bridge_pulse_trigger(bridge_item_t *c_item);
+#endif
+extern int remote_save_regs(int mode);
+extern int remote_restore_regs(int mode);
+
+
+#endif
diff --git a/drivers/amlogic/input/remote/remote_meson.c b/drivers/amlogic/input/remote/remote_meson.c
deleted file mode 100644
index bb2025298bd0..000000000000
--- a/drivers/amlogic/input/remote/remote_meson.c
+++ /dev/null
@@ -1,1013 +0,0 @@
-/*
- * drivers/amlogic/input/remote/remote_meson.c
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/types.h>
-#include <linux/input.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/errno.h>
-#include <asm/irq.h>
-#include <linux/io.h>
-#include <linux/major.h>
-#include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/uaccess.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/of_platform.h>
-#include <linux/amlogic/cpu_version.h>
-#include <linux/amlogic/pm.h>
-#include <linux/of_address.h>
-#include "remote_meson.h"
-#include <linux/amlogic/iomap.h>
-#include <linux/pm_wakeup.h>
-#include <linux/pm_wakeirq.h>
-#include <linux/amlogic/scpi_protocol.h>
-
-static void amlremote_tasklet(unsigned long data);
-static void learning_done_workqueue(struct work_struct *work);
-static void get_fifo_data_work(struct work_struct *work);
-
-DECLARE_TASKLET_DISABLED(tasklet, amlremote_tasklet, 0);
-
-static void learning_done_workqueue(struct work_struct *work)
-{
-	struct delayed_work *w = container_of(work, struct delayed_work, work);
-	struct remote_chip *chip =
-		container_of(w, struct remote_chip, ir_workqueue);
-	char *envp[2] = { "LEARN_DONE", NULL};
-
-	kobject_uevent_env(&chip->dev->kobj, KOBJ_CHANGE, envp);
-}
-
-int remote_pulses_malloc(struct remote_chip *chip)
-{
-	struct remote_dev *r_dev = chip->r_dev;
-	int len = r_dev->max_learned_pulse;
-	int ret = 0;
-
-	if (r_dev->pulses) {
-		dev_info(chip->dev, "ir learning pulse already exists\n");
-		return -EEXIST;
-	}
-
-	r_dev->pulses = kzalloc(sizeof(struct pulse_group) +
-			len * sizeof(unsigned int), GFP_KERNEL);
-
-	if (!r_dev->pulses) {
-		dev_err(chip->dev, "ir learning pulse alloc err\n");
-		ret = -ENOMEM;
-	}
-
-	return ret;
-}
-
-void remote_pulses_free(struct remote_chip *chip)
-{
-	struct remote_dev *r_dev = chip->r_dev;
-
-	kfree(r_dev->pulses);
-	r_dev->pulses = NULL;
-}
-
-int remote_reg_read(struct remote_chip *chip, unsigned char id,
-	unsigned int reg, unsigned int *val)
-{
-	if (id >= IR_ID_MAX) {
-		dev_err(chip->dev, "invalid id:[%d] in %s\n", id, __func__);
-		return -EINVAL;
-	}
-
-	*val = readl((chip->ir_contr[id].remote_regs+reg));
-
-	return 0;
-}
-
-int remote_reg_write(struct remote_chip *chip, unsigned char id,
-	unsigned int reg, unsigned int val)
-{
-	if (id >= IR_ID_MAX) {
-		dev_err(chip->dev, "invalid id:[%d] in %s\n", id, __func__);
-		return -EINVAL;
-	}
-
-	writel(val, (chip->ir_contr[id].remote_regs+reg));
-
-	return 0;
-}
-
-int remote_reg_update_bits(struct remote_chip *chip, unsigned char id,
-	unsigned int reg, unsigned int mask, unsigned int val)
-{
-	int orig = 0;
-
-	remote_reg_read(chip, id, reg, &orig);
-	orig &= ~mask;
-	orig |= val & mask;
-	remote_reg_write(chip, id, reg, orig);
-
-	return 0;
-}
-
-int ir_scancode_sort(struct ir_map_tab *ir_map)
-{
-	bool is_sorted;
-	u32 tmp;
-	int i;
-	int j;
-
-	for (i = 0; i < ir_map->map_size - 1; i++) {
-		is_sorted = true;
-		for (j = 0; j < ir_map->map_size - i - 1; j++) {
-			if (ir_map->codemap[j].map.scancode >
-					ir_map->codemap[j+1].map.scancode) {
-				is_sorted = false;
-				tmp = ir_map->codemap[j].code;
-				ir_map->codemap[j].code  =
-						ir_map->codemap[j+1].code;
-				ir_map->codemap[j+1].code = tmp;
-			}
-		}
-		if (is_sorted)
-			break;
-	}
-
-	return 0;
-}
-
-struct ir_map_tab_list *seek_map_tab(struct remote_chip *chip, int custom_code)
-{
-	struct ir_map_tab_list *ir_map = NULL;
-
-	list_for_each_entry(ir_map, &chip->map_tab_head, list) {
-		if (ir_map->tab.custom_code == custom_code)
-			return ir_map;
-	}
-	return NULL;
-}
-
-void ir_tab_free(struct ir_map_tab_list *ir_map_list)
-{
-	kfree((void *)ir_map_list);
-	ir_map_list = NULL;
-}
-
-static int ir_lookup_by_scancode(struct ir_map_tab *ir_map,
-					  unsigned int scancode)
-{
-	int start = 0;
-	int end = ir_map->map_size - 1;
-	int mid;
-
-	while (start <= end) {
-		mid = (start + end) >> 1;
-		if (ir_map->codemap[mid].map.scancode < scancode)
-			start = mid + 1;
-		else if (ir_map->codemap[mid].map.scancode > scancode)
-			end = mid - 1;
-		else
-			return mid;
-	}
-
-	return -1;
-}
-
-static int ir_report_rel(struct remote_dev *dev, u32 scancode, int status)
-{
-	struct remote_chip *chip = (struct remote_chip *)dev->platform_data;
-	struct ir_map_tab_list *ct = chip->cur_tab;
-	static u32 repeat_count;
-	s32 cursor_value = 0;
-	u32 valid_scancode;
-	u16 mouse_code;
-	s32 move_accelerate[] = CURSOR_MOVE_ACCELERATE;
-
-	/*nothing need to do in normal mode*/
-	if (!ct || (ct->ir_dev_mode != MOUSE_MODE))
-		return -EINVAL;
-
-	if (status == REMOTE_REPEAT) {
-		valid_scancode = dev->last_scancode;
-		repeat_count++;
-		if (repeat_count > ARRAY_SIZE(move_accelerate) - 1)
-			repeat_count = ARRAY_SIZE(move_accelerate) - 1;
-	} else {
-		valid_scancode = scancode;
-		dev->last_scancode = scancode;
-		repeat_count = 0;
-	}
-	if (valid_scancode == ct->tab.cursor_code.cursor_left_scancode) {
-		cursor_value = -(1 + move_accelerate[repeat_count]);
-		mouse_code = REL_X;
-	} else if (valid_scancode ==
-			ct->tab.cursor_code.cursor_right_scancode) {
-		cursor_value = 1 + move_accelerate[repeat_count];
-		mouse_code = REL_X;
-	} else if (valid_scancode ==
-			ct->tab.cursor_code.cursor_up_scancode) {
-		cursor_value = -(1 + move_accelerate[repeat_count]);
-		mouse_code = REL_Y;
-	} else if (valid_scancode ==
-			ct->tab.cursor_code.cursor_down_scancode) {
-		cursor_value = 1 + move_accelerate[repeat_count];
-		mouse_code = REL_Y;
-	} else {
-		return -EINVAL;
-	}
-	input_event(chip->r_dev->input_device, EV_REL,
-			mouse_code, cursor_value);
-	input_sync(chip->r_dev->input_device);
-
-	remote_dbg(chip->dev, "mouse cursor be %s moved %d.\n",
-				mouse_code == REL_X ? "horizontal" :
-					"vertical",
-					cursor_value);
-
-	return 0;
-}
-
-static u32 getkeycode(struct remote_dev *dev, u32 scancode)
-{
-	struct remote_chip *chip = (struct remote_chip *)dev->platform_data;
-	struct ir_map_tab_list *ct = chip->cur_tab;
-	int index;
-
-	if (!ct) {
-		dev_err(chip->dev, "cur_custom is nulll\n");
-		return KEY_RESERVED;
-	}
-	/*return BTN_LEFT in mouse mode*/
-	if (ct->ir_dev_mode == MOUSE_MODE &&
-			scancode == ct->tab.cursor_code.cursor_ok_scancode) {
-		remote_dbg(chip->dev, "mouse left button scancode: 0x%x",
-					BTN_LEFT);
-		return BTN_LEFT;
-	}
-
-	index = ir_lookup_by_scancode(&ct->tab, scancode);
-	if (index < 0) {
-		dev_err(chip->dev, "scancode %d undefined\n", scancode);
-		return KEY_RESERVED;
-	}
-
-	/*save remote-control work mode*/
-	if (dev->keypressed == false &&
-			scancode == ct->tab.cursor_code.fn_key_scancode) {
-		if (ct->ir_dev_mode == NORMAL_MODE)
-			ct->ir_dev_mode = MOUSE_MODE;
-		else
-			ct->ir_dev_mode = NORMAL_MODE;
-		dev_info(chip->dev, "remote control[ID: 0x%x] switch to %s\n",
-					ct->tab.custom_code,
-					ct->ir_dev_mode ?
-					"mouse mode":"normal mode");
-	}
-
-	return ct->tab.codemap[index].map.keycode;
-}
-
-static bool is_valid_custom(struct remote_dev *dev)
-{
-	struct remote_chip *chip = (struct remote_chip *)dev->platform_data;
-	int custom_code;
-
-	if (!chip->ir_contr[chip->ir_work].get_custom_code)
-		return true;
-	custom_code = chip->ir_contr[chip->ir_work].get_custom_code(chip);
-	chip->cur_tab = seek_map_tab(chip, custom_code);
-	if (chip->cur_tab) {
-		dev->keyup_delay = chip->cur_tab->tab.release_delay;
-		return true;
-	}
-	return false;
-}
-
-static bool is_next_repeat(struct remote_dev *dev)
-{
-	unsigned int val = 0;
-	unsigned char fbusy = 0;
-	unsigned char cnt;
-
-	struct remote_chip *chip = (struct remote_chip *)dev->platform_data;
-
-	for (cnt = 0; cnt < (ENABLE_LEGACY_IR(chip->protocol) ? 2:1); cnt++) {
-		remote_reg_read(chip, cnt, REG_STATUS, &val);
-		fbusy |= IR_CONTROLLER_BUSY(val);
-	}
-	remote_dbg(chip->dev, "ir controller busy flag = %d\n", fbusy);
-	if (!dev->wait_next_repeat && fbusy)
-		return true;
-	else
-		return false;
-}
-
-static bool set_custom_code(struct remote_dev *dev, u32 code)
-{
-	struct remote_chip *chip = (struct remote_chip *)dev->platform_data;
-
-	return chip->ir_contr[chip->ir_work].set_custom_code(chip, code);
-}
-
-static void amlremote_tasklet(unsigned long data)
-{
-	struct remote_chip *chip = (struct remote_chip *)data;
-	unsigned long flags;
-	int status = -1;
-	int scancode = -1;
-
-	/**
-	 *need first get_scancode, then get_decode_status, the status
-	 *may was set flag from get_scancode function
-	 */
-	spin_lock_irqsave(&chip->slock, flags);
-	if (chip->ir_contr[chip->ir_work].get_scancode)
-		scancode = chip->ir_contr[chip->ir_work].get_scancode(chip);
-	if (chip->ir_contr[chip->ir_work].get_decode_status)
-		status = chip->ir_contr[chip->ir_work].get_decode_status(chip);
-	if (status == REMOTE_NORMAL) {
-		remote_dbg(chip->dev, "receive scancode=0x%x\n", scancode);
-		remote_keydown(chip->r_dev, scancode, status);
-	} else if (status & REMOTE_REPEAT) {
-		remote_dbg(chip->dev, "receive repeat\n");
-		remote_keydown(chip->r_dev, scancode, status);
-	} else
-		dev_err(chip->dev, "receive error %d\n", status);
-	spin_unlock_irqrestore(&chip->slock, flags);
-
-}
-
-static void get_fifo_data_work(struct work_struct *work)
-{
-	struct remote_chip *chip =
-		container_of(work, struct remote_chip, fifo_work);
-	struct remote_dev *r_dev = chip->r_dev;
-	int val = 0;
-	int is_fifo_pending = 0;
-	int is_fifo_timeout = 0;
-	int is_fifo_empty = 0;
-	u32 duration = 0;
-
-	remote_reg_read(chip, MULTI_IR_ID, REG_FIFO, &val);
-	is_fifo_pending = (val >> 30) & 0x01;
-	is_fifo_timeout = (val >> 29) & 0x01;
-	is_fifo_empty = (val >> 27) & 0x01;
-
-	/*disable  interrupt*/
-	remote_reg_update_bits(chip, MULTI_IR_ID, REG_FIFO, GENMASK(22, 23), 0);
-
-	if (is_fifo_pending || is_fifo_timeout) {
-		/*clear state*/
-		remote_reg_update_bits(chip, MULTI_IR_ID, REG_FIFO,
-				       GENMASK(29, 30), GENMASK(29, 30));
-
-		for (; !is_fifo_empty; ) {
-
-			remote_reg_read(chip, MULTI_IR_ID, REG_WITH, &val);
-			val = val & GENMASK(12, 0);
-
-			duration = val;
-			r_dev->pulses->pulse[r_dev->pulses->len] = duration;
-
-			if (r_dev->pulses->len % 2 == 1)
-				r_dev->pulses->pulse[r_dev->pulses->len]
-					|= BIT(31);
-
-			r_dev->pulses->len++;
-
-			remote_reg_read(chip, MULTI_IR_ID, REG_FIFO, &val);
-			is_fifo_empty = (val >> 27) & 0x01;
-
-		}
-	}
-
-	/*enable interrupt*/
-	remote_reg_update_bits(chip, MULTI_IR_ID, REG_FIFO, GENMASK(22, 23),
-			       GENMASK(22, 23));
-
-	if (r_dev->auto_report)
-		mod_timer(&r_dev->learning_done,
-			  jiffies + msecs_to_jiffies(50));
-}
-
-static irqreturn_t ir_interrupt(int irq, void *dev_id)
-{
-	struct remote_chip *rc = (struct remote_chip *)dev_id;
-	struct remote_dev *r_dev = rc->r_dev;
-	struct pulse_group *pgs;
-	int contr_status = 0;
-	int val = 0;
-	u32 duration;
-	char buf[50];
-	unsigned char cnt;
-	enum raw_event_type type = RAW_SPACE;
-
-	remote_reg_read(rc, MULTI_IR_ID, REG_REG1, &val);
-	val = (val & 0x1FFF0000) >> 16;
-	sprintf(buf, "duration:%d\n", val);
-	debug_log_printk(rc->r_dev, buf);
-	/**
-	 *software decode multiple protocols by using Time Measurement of
-	 *multif-format IR controller
-	 */
-
-	if (r_dev->ir_learning_on && !r_dev->ir_learning_done) {
-		pgs = r_dev->pulses;
-		if (pgs->len >= r_dev->max_learned_pulse) {
-			remote_reg_update_bits(rc, MULTI_IR_ID, REG_REG1,
-					       BIT(15), 0);
-			return IRQ_HANDLED;
-		}
-		if (!r_dev->use_fifo) {
-			if (r_dev->auto_report)
-				mod_timer(&r_dev->learning_done,
-					  jiffies + msecs_to_jiffies(50));
-			/*get pulse durations unit:10us*/
-			pgs->pulse[pgs->len] = val & GENMASK(30, 0);
-			/*get pulse level*/
-			remote_reg_read(rc, MULTI_IR_ID, REG_STATUS, &val);
-			val = !!((val >> 8) & 0x01);
-			pgs->pulse[pgs->len] &= ~BIT(31);
-			if (val)
-				pgs->pulse[pgs->len] |= BIT(31);
-
-			r_dev->pulses->len++;
-		} else {
-			schedule_work(&rc->fifo_work);
-		}
-		return IRQ_HANDLED;
-	}
-
-	if (MULTI_IR_SOFTWARE_DECODE(rc->protocol)) {
-		rc->ir_work = MULTI_IR_ID;
-		duration = val*10*1000;
-		type    = RAW_PULSE;
-		sprintf(buf, "------\n");
-		debug_log_printk(rc->r_dev, buf);
-		remote_raw_event_store_edge(rc->r_dev, type, duration);
-		remote_raw_event_handle(rc->r_dev);
-	} else {
-		for (cnt = 0; cnt < (ENABLE_LEGACY_IR(rc->protocol)
-				? 2:1); cnt++) {
-			remote_reg_read(rc, cnt, REG_STATUS, &contr_status);
-			if (IR_DATA_IS_VALID(contr_status)) {
-				rc->ir_work = cnt;
-				break;
-			}
-		}
-
-		if (cnt == IR_ID_MAX) {
-			dev_err(rc->dev, "invalid interrupt.\n");
-			return IRQ_HANDLED;
-		}
-
-		tasklet_schedule(&tasklet);
-	}
-	return IRQ_HANDLED;
-}
-
-static int get_custom_tables(struct device_node *node,
-	struct remote_chip *chip)
-{
-	const phandle *phandle;
-	struct device_node *custom_maps, *map;
-	u32 value;
-	int ret = -1;
-	int index;
-	char *propname;
-	const char *uname;
-	unsigned long flags;
-	struct ir_map_tab_list *ptable;
-
-	phandle = of_get_property(node, "map", NULL);
-	if (!phandle) {
-		dev_err(chip->dev, "%s:don't find match custom\n", __func__);
-		return -1;
-	}
-
-	custom_maps = of_find_node_by_phandle(be32_to_cpup(phandle));
-	if (!custom_maps) {
-		dev_err(chip->dev, "can't find device node key\n");
-		return -1;
-	}
-
-	ret = of_property_read_u32(custom_maps, "mapnum", &value);
-	if (ret) {
-		dev_err(chip->dev, "please config correct mapnum item\n");
-		return -1;
-	}
-	chip->custom_num = value;
-	if (chip->custom_num > CUSTOM_NUM_MAX)
-		chip->custom_num = CUSTOM_NUM_MAX;
-
-	dev_info(chip->dev, "custom_number = %d\n", chip->custom_num);
-
-	for (index = 0; index < chip->custom_num; index++) {
-		propname = kasprintf(GFP_KERNEL, "map%d", index);
-		phandle = of_get_property(custom_maps, propname, NULL);
-
-		/* never use below, just use to find phandle
-		 * mem leak occurs if not free
-		 */
-		kfree(propname);
-		propname = NULL;
-
-		if (!phandle) {
-			dev_err(chip->dev, "%s:don't find match map%d\n",
-					__func__, index);
-			return -1;
-		}
-		map = of_find_node_by_phandle(be32_to_cpup(phandle));
-		if (!map) {
-			dev_err(chip->dev, "can't find device node key\n");
-			return -1;
-		}
-
-		ret = of_property_read_u32(map, "size", &value);
-		if (ret || value > MAX_KEYMAP_SIZE) {
-			dev_err(chip->dev, "no config size item or err\n");
-			return -1;
-		}
-
-		/*alloc memory*/
-		ptable = kzalloc(sizeof(struct ir_map_tab_list) +
-				    value * sizeof(union _codemap), GFP_KERNEL);
-		if (!ptable)
-			return -ENOMEM;
-
-		ptable->tab.map_size = value;
-		dev_info(chip->dev, "ptable->map_size = %d\n",
-							ptable->tab.map_size);
-
-		ret = of_property_read_string(map, "mapname", &uname);
-		if (ret) {
-			dev_err(chip->dev, "please config mapname item\n");
-			goto err;
-		}
-		snprintf(ptable->tab.custom_name, CUSTOM_NAME_LEN, "%s", uname);
-
-		dev_info(chip->dev, "ptable->custom_name = %s\n",
-						ptable->tab.custom_name);
-
-		ret = of_property_read_u32(map, "customcode", &value);
-		if (ret) {
-			dev_err(chip->dev, "please config customcode item\n");
-			goto err;
-		}
-		ptable->tab.custom_code = value;
-		dev_info(chip->dev, "ptable->custom_code = 0x%x\n",
-						ptable->tab.custom_code);
-
-		ret = of_property_read_u32(map, "release_delay", &value);
-		if (ret) {
-			dev_err(chip->dev, "remote:don't find the node <release_delay>\n");
-			goto err;
-		}
-		ptable->tab.release_delay = value;
-		dev_info(chip->dev, "ptable->release_delay = %d\n",
-						ptable->tab.release_delay);
-
-		ret = of_property_read_u32_array(map,
-				"keymap", (u32 *)&ptable->tab.codemap[0],
-					ptable->tab.map_size);
-		if (ret) {
-			dev_err(chip->dev, "please config keymap item\n");
-			goto err;
-		}
-
-		memset(&ptable->tab.cursor_code, 0xff,
-					sizeof(struct cursor_codemap));
-		ir_scancode_sort(&ptable->tab);
-		/*insert list*/
-		spin_lock_irqsave(&chip->slock, flags);
-		list_add_tail(&ptable->list, &chip->map_tab_head);
-		spin_unlock_irqrestore(&chip->slock, flags);
-
-	}
-	return 0;
-err:
-	ir_tab_free(ptable);
-	return -1;
-}
-
-
-static int ir_get_devtree_pdata(struct platform_device *pdev)
-{
-	struct resource *res_irq;
-	struct resource *res_mem;
-	resource_size_t *res_start[2];
-	struct pinctrl *p;
-	int ret;
-	int value = 0;
-	unsigned char i;
-
-
-	struct remote_chip *chip = platform_get_drvdata(pdev);
-
-	ret = of_property_read_u32(pdev->dev.of_node,
-			"protocol", &chip->protocol);
-	if (ret) {
-		dev_err(chip->dev, "don't find the node <protocol>\n");
-		chip->protocol = 1;
-	}
-	dev_info(chip->dev, "protocol = 0x%x\n", chip->protocol);
-
-	ret = of_property_read_u32(pdev->dev.of_node,
-			"led_blink", &chip->r_dev->led_blink);
-	if (ret) {
-		dev_err(chip->dev, "don't find the node <led_blink>\n");
-		chip->r_dev->led_blink = 0;
-	}
-	dev_info(chip->dev, "led_blink = %d\n", chip->r_dev->led_blink);
-
-	ret = of_property_read_u32(pdev->dev.of_node,
-			"led_blink_frq", &value);
-	if (ret) {
-		dev_err(chip->dev, "don't find the node <led_blink_frq>\n");
-		chip->r_dev->delay_on = DEFAULT_LED_BLINK_FRQ;
-		chip->r_dev->delay_off = DEFAULT_LED_BLINK_FRQ;
-	} else {
-		chip->r_dev->delay_off = value;
-		chip->r_dev->delay_on = value;
-	}
-	dev_info(chip->dev, "led_blink_frq  = %ld\n", chip->r_dev->delay_on);
-
-	ret = of_property_read_bool(pdev->dev.of_node, "demod_enable");
-	if (ret)
-		chip->r_dev->demod_enable = 1;
-
-	ret = of_property_read_bool(pdev->dev.of_node, "use_fifo");
-	if (ret)
-		chip->r_dev->use_fifo = 1;
-
-	ret = of_property_read_bool(pdev->dev.of_node, "auto_report");
-	if (ret)
-		chip->r_dev->auto_report = 1;
-
-	p = devm_pinctrl_get_select_default(&pdev->dev);
-	if (IS_ERR(p)) {
-		dev_err(chip->dev, "pinctrl error, %ld\n", PTR_ERR(p));
-		return -1;
-	}
-
-	for (i = 0; i < 2; i++) {
-		res_mem = platform_get_resource(pdev, IORESOURCE_MEM, i);
-		if (IS_ERR_OR_NULL(res_mem)) {
-			dev_err(chip->dev, "get IORESOURCE_MEM error, %ld\n",
-					PTR_ERR(p));
-			return PTR_ERR(res_mem);
-		}
-		res_start[i] = devm_ioremap_resource(&pdev->dev, res_mem);
-		chip->ir_contr[i].remote_regs = (void __iomem *)res_start[i];
-	}
-
-	res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (IS_ERR_OR_NULL(res_irq)) {
-		dev_err(chip->dev, "get IORESOURCE_IRQ error, %ld\n",
-				PTR_ERR(p));
-		return PTR_ERR(res_irq);
-	}
-
-	chip->irqno = res_irq->start;
-
-	dev_info(chip->dev, "platform_data irq =%d\n", chip->irqno);
-
-	ret = of_property_read_u32(pdev->dev.of_node,
-				"max_frame_time", &value);
-	if (ret) {
-		dev_err(chip->dev, "don't find the node <max_frame_time>\n");
-		value = 200; /*default value*/
-	}
-
-	chip->r_dev->max_frame_time = value;
-
-
-	/*create map table */
-	get_custom_tables(pdev->dev.of_node, chip);
-
-	return 0;
-}
-
-void demod_init(struct remote_chip *chip)
-{
-	int val;
-	unsigned int  mask;
-
-	mask = GENMASK(29, 16) | BIT(31);
-	val = BIT(31) | (0x1FF << 16);
-
-	remote_reg_update_bits(chip, MULTI_IR_ID, REG_DEMOD_CNTL1, mask, val);
-}
-
-void demod_reset(struct remote_chip *chip)
-{
-	unsigned int mask;
-
-	mask = BIT(30);
-	remote_reg_update_bits(chip, MULTI_IR_ID, REG_DEMOD_CNTL0, mask, mask);
-}
-
-static void ir_learning_done(unsigned long cookie)
-{
-
-	struct remote_dev *dev = (struct remote_dev *)cookie;
-	struct remote_chip *chip = (struct remote_chip *) dev->platform_data;
-	unsigned long flags;
-
-	if (dev->pulses->len < 3) {
-		dev->pulses->len = 0;
-		return;
-	}
-
-	spin_lock_irqsave(&chip->slock, flags);
-	dev->ir_learning_done = true;
-	spin_unlock_irqrestore(&chip->slock, flags);
-
-	/*data recive done*/
-	remote_reg_update_bits(chip, MULTI_IR_ID, REG_REG1, BIT(15), 0);
-	schedule_delayed_work(&chip->ir_workqueue, msecs_to_jiffies(100));
-
-}
-
-static int ir_hardware_init(struct platform_device *pdev)
-{
-	int ret;
-
-	struct remote_chip *chip = platform_get_drvdata(pdev);
-
-	if (!pdev->dev.of_node) {
-		dev_err(chip->dev, "pdev->dev.of_node == NULL!\n");
-		return -1;
-	}
-
-	ret = ir_get_devtree_pdata(pdev);
-	if (ret < 0)
-		return ret;
-	chip->set_register_config(chip, chip->protocol);
-	ret = request_irq(chip->irqno, ir_interrupt, IRQF_SHARED
-		| IRQF_NO_SUSPEND, "keypad", (void *)chip);
-	if (ret < 0)
-		goto error_irq;
-
-	chip->irq_cpumask = 1;
-
-	tasklet_enable(&tasklet);
-	tasklet.data = (unsigned long)chip;
-
-	return 0;
-
-error_irq:
-	dev_err(chip->dev, "request_irq error %d\n", ret);
-
-	return ret;
-
-}
-
-static int ir_hardware_free(struct platform_device *pdev)
-{
-	struct remote_chip *chip = platform_get_drvdata(pdev);
-
-	free_irq(chip->irqno, chip);
-	return 0;
-}
-
-static void ir_input_device_init(struct input_dev *dev,
-	struct device *parent, const char *name)
-{
-	dev->name = name;
-	dev->phys = "keypad/input0";
-	dev->dev.parent = parent;
-	dev->id.bustype = BUS_ISA;
-	dev->id.vendor  = 0x0001;
-	dev->id.product = 0x0001;
-	dev->id.version = 0x0100;
-	dev->rep[REP_DELAY] = 0xffffffff;  /*close input repeat*/
-	dev->rep[REP_PERIOD] = 0xffffffff; /*close input repeat*/
-}
-
-static int remote_probe(struct platform_device *pdev)
-{
-	struct remote_dev *dev;
-	int ret;
-	struct remote_chip *chip;
-
-	pr_info("%s: remote_probe\n", DRIVER_NAME);
-	chip = kzalloc(sizeof(struct remote_chip), GFP_KERNEL);
-	if (!chip) {
-		pr_err("%s: kzalloc remote_chip error!\n", DRIVER_NAME);
-		ret = -ENOMEM;
-		goto err_end;
-	}
-
-	dev = remote_allocate_device();
-	if (!dev) {
-		pr_err("%s: kzalloc remote_dev error!\n", DRIVER_NAME);
-		ret = -ENOMEM;
-		goto err_alloc_remote_dev;
-	}
-
-	mutex_init(&chip->file_lock);
-	spin_lock_init(&chip->slock);
-	INIT_LIST_HEAD(&chip->map_tab_head);
-
-	chip->r_dev = dev;
-	chip->dev = &pdev->dev;
-
-	chip->r_dev->dev = &pdev->dev;
-	chip->r_dev->platform_data = (void *)chip;
-	chip->r_dev->getkeycode    = getkeycode;
-	chip->r_dev->ir_report_rel = ir_report_rel;
-	chip->r_dev->set_custom_code = set_custom_code;
-	chip->r_dev->is_valid_custom = is_valid_custom;
-	chip->r_dev->is_next_repeat  = is_next_repeat;
-	chip->r_dev->max_learned_pulse = MAX_LEARNED_PULSE;
-	chip->set_register_config = ir_register_default_config;
-	platform_set_drvdata(pdev, chip);
-
-	ir_input_device_init(dev->input_device, &pdev->dev, "aml_keypad");
-
-	ret = ir_hardware_init(pdev);
-	if (ret < 0)
-		goto err_hard_init;
-
-	ret = ir_cdev_init(chip);
-	if (ret < 0)
-		goto err_cdev_init;
-
-	dev->rc_type = chip->protocol;
-	ret = remote_register_device(dev);
-	if (ret)
-		goto error_register_remote;
-
-	device_init_wakeup(&pdev->dev, 1);
-	dev_pm_set_wake_irq(&pdev->dev, chip->irqno);
-
-	led_trigger_register_simple("rc_feedback", &dev->led_feedback);
-
-	setup_timer(&dev->learning_done, ir_learning_done, (unsigned long)dev);
-	if (dev->demod_enable)
-		demod_init(chip);
-	INIT_DELAYED_WORK(&chip->ir_workqueue, learning_done_workqueue);
-	INIT_WORK(&chip->fifo_work, get_fifo_data_work);
-	return 0;
-
-error_register_remote:
-	ir_hardware_free(pdev);
-err_cdev_init:
-	remote_free_device(dev);
-err_hard_init:
-	ir_cdev_free(chip);
-err_alloc_remote_dev:
-	kfree(chip);
-err_end:
-	return ret;
-}
-
-static int remote_remove(struct platform_device *pdev)
-{
-	struct remote_chip *chip = platform_get_drvdata(pdev);
-
-	tasklet_disable(&tasklet);
-	tasklet_kill(&tasklet);
-
-	free_irq(chip->irqno, chip); /*irq dev_id is chip address*/
-	led_trigger_unregister_simple(chip->r_dev->led_feedback);
-	ir_cdev_free(chip);
-	remote_unregister_device(chip->r_dev);
-	remote_free_device(chip->r_dev);
-	dev_pm_clear_wake_irq(&pdev->dev);
-	device_init_wakeup(&pdev->dev, false);
-
-	kfree(chip);
-	return 0;
-}
-
-static int remote_resume(struct device *dev)
-{
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	unsigned int val;
-	unsigned long flags;
-	unsigned char cnt;
-
-	if (is_pm_freeze_mode())
-		return 0;
-
-	dev_info(dev, "remote resume\n");
-	/*resume register config*/
-	spin_lock_irqsave(&chip->slock, flags);
-	chip->set_register_config(chip, chip->protocol);
-	/* read REG_STATUS and REG_FRAME to clear status */
-	for (cnt = 0; cnt < (ENABLE_LEGACY_IR(chip->protocol) ? 2:1); cnt++) {
-		remote_reg_read(chip, cnt, REG_STATUS, &val);
-		remote_reg_read(chip, cnt, REG_FRAME, &val);
-	}
-	spin_unlock_irqrestore(&chip->slock, flags);
-
-#ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
-	if (get_resume_method() == REMOTE_WAKEUP) {
-		input_event(chip->r_dev->input_device,
-		    EV_KEY, KEY_POWER, 1);
-		input_sync(chip->r_dev->input_device);
-		input_event(chip->r_dev->input_device,
-		    EV_KEY, KEY_POWER, 0);
-		input_sync(chip->r_dev->input_device);
-		if (scpi_clr_wakeup_reason())
-			pr_debug("clr wakeup reason fail.\n");
-	}
-
-	if (get_resume_method() == REMOTE_CUS_WAKEUP) {
-		input_event(chip->r_dev->input_device, EV_KEY, 133, 1);
-		input_sync(chip->r_dev->input_device);
-		input_event(chip->r_dev->input_device, EV_KEY, 133, 0);
-		input_sync(chip->r_dev->input_device);
-		if (scpi_clr_wakeup_reason())
-			pr_debug("clr wakeup reason fail.\n");
-	}
-#endif
-
-	enable_irq(chip->irqno);
-	return 0;
-}
-
-static int remote_suspend(struct device *dev)
-{
-	struct remote_chip *chip = dev_get_drvdata(dev);
-
-	if (chip->r_dev->ir_learning_on) {
-		cancel_work_sync(&chip->fifo_work);
-		del_timer_sync(&chip->r_dev->learning_done);
-		cancel_delayed_work_sync(&chip->ir_workqueue);
-	}
-
-	if (is_pm_freeze_mode())
-		return 0;
-
-	dev_info(dev, "remote suspend\n");
-	disable_irq(chip->irqno);
-	return 0;
-}
-
-static const struct of_device_id remote_dt_match[] = {
-	{
-		.compatible     = "amlogic, aml_remote",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, remote_dt_match);
-
-#ifdef CONFIG_PM
-static const struct dev_pm_ops remote_pm_ops = {
-	.suspend_late = remote_suspend,
-	.resume_early = remote_resume,
-};
-#endif
-
-static struct platform_driver remote_driver = {
-	.probe = remote_probe,
-	.remove = remote_remove,
-	.driver = {
-		.name = DRIVER_NAME,
-		.of_match_table = remote_dt_match,
-#ifdef CONFIG_PM
-		.pm = &remote_pm_ops,
-#endif
-	},
-};
-
-static int __init remote_init(void)
-{
-	pr_info("%s: Driver init\n", DRIVER_NAME);
-	return platform_driver_register(&remote_driver);
-}
-
-static void __exit remote_exit(void)
-{
-	pr_info("%s: Driver exit\n", DRIVER_NAME);
-	platform_driver_unregister(&remote_driver);
-}
-
-module_init(remote_init);
-module_exit(remote_exit);
-
-
-MODULE_AUTHOR("AMLOGIC");
-MODULE_DESCRIPTION("AMLOGIC REMOTE PROTOCOL");
-MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/input/remote/remote_meson.h b/drivers/amlogic/input/remote/remote_meson.h
deleted file mode 100644
index aa7538a74582..000000000000
--- a/drivers/amlogic/input/remote/remote_meson.h
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
- * drivers/amlogic/input/remote/remote_meson.h
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#ifndef _REMOTE_MESON_H
-#define _REMOTE_MESON_H
-#include <linux/cdev.h>
-#include "rc_common.h"
-#include "remote_core.h"
-
-#define DRIVER_NAME "meson-remote"
-
-#define IR_DATA_IS_VALID(data) (data & 0x8)
-#define IR_CONTROLLER_BUSY(x) ((x >> 7) & 0x1)
-#define CURSOR_MOVE_ACCELERATE {0, 2, 2, 4, 4, 6, 8, 10, 12, 14, 16, 18}
-/*bit 31: enable fifo mode
- * bit 21-23: time out/level trigger interrupt
- * bit 13-20: trigger interrupt when receive specified numbers of pulse
- * bit 0-12: trigger interrupt when time out
- */
-#define FIFO_REG_VAL ((1 << 31) | (7 << 21) | (80 << 13) | (5000 << 0))
-
-enum IR_CONTR_NUMBER {
-	MULTI_IR_ID = 0,
-	LEGACY_IR_ID,
-	IR_ID_MAX
-};
-
-enum IR_WORK_MODE {
-	NORMAL_MODE = 0,
-	MOUSE_MODE = 1
-};
-
-struct remote_range {
-	struct range active;
-	struct range idle;
-	struct range repeat;
-	struct range bit_zero_zero;
-	struct range bit_zero_one;
-	struct range bit_one_zero;
-	struct range bit_one_one;
-};
-
-struct remote_reg_map {
-	unsigned int reg;
-	unsigned int val;
-};
-
-/*
- *struct ir_map_tab_list
- *
- *@ir_dev_mode: 0: normal mode; 1: mouse mode
- *@list:
- *@tab:
- */
-struct ir_map_tab_list {
-	bool ir_dev_mode;
-	struct list_head list;
-	struct ir_map_tab tab;
-};
-
-struct cdev;
-struct remote_chip;
-
-/**
- *struct key_number - to save the number of key for map table
- *
- *@update_flag: to ensure get key number before map table
- *@value:
- */
-struct key_number {
-	bool update_flag;
-	int  value;
-};
-
-/**
- *struct remote_contr_desc - describe the different properties and methods
- *for the Legacy IR controller and multi-format IR controller.
- *TODO: compatible with the "struct aml_remote_reg_proto"
- */
-struct remote_contr_desc {
-	void __iomem *remote_regs;
-	char *proto_name;
-	int (*get_scancode)(struct remote_chip *chip);
-	int (*get_decode_status)(struct remote_chip *chip);
-	u32 (*get_custom_code)(struct remote_chip *chip);
-	bool (*set_custom_code)(struct remote_chip *chip, u32 code);
-};
-/**
- *struct remote_chip - describe the common properties and methods
- * for the Legacy IR controller and multi-format IR controller.
- */
-struct remote_chip {
-	struct device *dev;
-	struct remote_dev *r_dev;
-	struct remote_range reg_duration;
-	char *dev_name;
-	int protocol;
-	struct delayed_work ir_workqueue;
-	struct work_struct fifo_work;
-
-	dev_t chr_devno;
-	struct class  *chr_class;
-	struct cdev chrdev;
-	struct mutex  file_lock;
-	spinlock_t slock;
-
-	bool debug_enable;
-	bool repeat_enable;
-#define CUSTOM_TABLES_SIZE 20
-#define CUSTOM_NUM_MAX 20
-	struct list_head map_tab_head;
-	struct ir_map_tab_list *cur_tab;
-	int custom_num;
-	struct key_number key_num;
-	int decode_status;
-	int sys_custom_code;
-	const char *keymap_name;
-	int	irqno;       /*irq number*/
-	int	irq_cpumask;
-	/**
-	 *indicate which ir controller working.
-	 *0: multi format IR
-	 *1: legacy IR
-	 */
-	unsigned char ir_work;
-	/**
-	 *multi_format IR controller register saved to ir_contr[0]
-	 *legacy IR controller register saved to ir_contr[1]
-	 */
-	struct remote_contr_desc ir_contr[2];
-
-	/*software decode*/
-	unsigned char bit_count;
-	unsigned short time_window[18];
-
-	int (*report_key)(struct remote_chip *chip);
-	int (*release_key)(struct remote_chip *chip);
-	int (*set_register_config)(struct remote_chip *chip, int type);
-	int (*debug_printk)(const char *, ...);
-};
-
-struct aml_remote_reg_proto {
-	int protocol;
-	char *name;
-	struct aml_remote_reg *reg;
-	struct remote_reg_map *reg_map;
-	int reg_map_size;
-	int (*get_scancode)(struct remote_chip *chip);
-	int (*get_decode_status)(struct remote_chip *chip);
-	u32 (*get_custom_code)(struct remote_chip *chip);
-	bool (*set_custom_code)(struct remote_chip *chip, u32 code);
-};
-
-enum {
-	DECODE_MODE_NEC			= 0x00,
-	DECODE_MODE_SKIP_LEADER = 0x01,
-	DECODE_MODE_SOFTWARE    = 0x02,
-	DECODE_MODE_MITSUBISHI_OR_50560 = 0x03,
-	DECODE_MODE_DUOKAN = 0x0B
-};
-
-enum remote_reg {
-	REG_LDR_ACTIVE		= 0x00 << 2,
-	REG_LDR_IDLE		= 0x01 << 2,
-	REG_LDR_REPEAT		= 0x02 << 2,
-	REG_BIT_0		= 0x03 << 2,
-	REG_REG0		= 0x04 << 2,
-	REG_FRAME		= 0x05 << 2,
-	REG_STATUS		= 0x06 << 2,
-	REG_REG1		= 0x07 << 2,
-	REG_REG2		= 0x08 << 2,
-	REG_DURATN2		= 0x09 << 2,
-	REG_DURATN3		= 0x0a << 2,
-	REG_FRAME1		= 0x0b << 2,
-	REG_STATUS1		= 0x0c << 2,
-	REG_STATUS2		= 0x0d << 2,
-	REG_REG3		= 0x0e << 2,
-	REG_FRAME_RSV0		= 0x0f << 2,
-	REG_FRAME_RSV1		= 0x10 << 2,
-	REG_IRQ_CTL		= 0x12 << 2,
-	REG_FIFO		= 0x13 << 2,
-	REG_WITH		= 0x14 << 2,
-	REG_REPEAT_DET		= 0x15 << 2,
-	REG_DEMOD_CNTL0		= 0x20 << 2,
-	REG_DEMOD_CNTL1		= 0x21 << 2,
-	REG_DEMOD_IIR_THD	= 0x22 << 2,
-	REG_DEMOD_THD0		= 0x23 << 2,
-	REG_DEMOD_THD1		= 0x24 << 2,
-	REG_DEMOD_SUM_CNT0	= 0x25 << 2,
-	REG_DEMOD_SUM_CNT1	= 0x26 << 2,
-	REG_DEMOD_CNT0		= 0x27 << 2,
-	REG_DEMOD_CNT1		= 0x28 << 2
-};
-
-int ir_register_default_config(struct remote_chip *chip, int type);
-int ir_cdev_init(struct remote_chip *chip);
-void ir_cdev_free(struct remote_chip *chip);
-
-
-int remote_reg_read(struct remote_chip *chip, unsigned char id,
-	unsigned int reg, unsigned int *val);
-int remote_reg_write(struct remote_chip *chip, unsigned char id,
-	unsigned int reg, unsigned int val);
-int remote_reg_update_bits(struct remote_chip *chip, unsigned char id,
-	unsigned int reg, unsigned int mask, unsigned int val);
-int ir_scancode_sort(struct ir_map_tab *ir_map);
-struct ir_map_tab_list *seek_map_tab(struct remote_chip *chip, int custom_code);
-const struct aml_remote_reg_proto **ir_get_proto_reg(void);
-void ir_tab_free(struct ir_map_tab_list *ir_map_list);
-int remote_pulses_malloc(struct remote_chip *chip);
-void remote_pulses_free(struct remote_chip *chip);
-void demod_reset(struct remote_chip *chip);
-void demod_init(struct remote_chip *chip);
-#endif
diff --git a/drivers/amlogic/input/remote/remote_raw.c b/drivers/amlogic/input/remote/remote_raw.c
deleted file mode 100644
index 2edd6592e703..000000000000
--- a/drivers/amlogic/input/remote/remote_raw.c
+++ /dev/null
@@ -1,209 +0,0 @@
-/*
- * drivers/amlogic/input/remote/remote_raw.c
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#include <linux/export.h>
-#include <linux/kthread.h>
-#include <linux/mutex.h>
-#include <linux/kmod.h>
-#include <linux/sched.h>
-#include <linux/freezer.h>
-#include <linux/jiffies.h>
-#include "remote_meson.h"
-
-static DEFINE_MUTEX(remote_raw_handler_lock);
-static LIST_HEAD(remote_raw_handler_list);
-static LIST_HEAD(remote_raw_client_list);
-
-#define MAX_REMOTE_EVENT_SIZE      512
-
-
-static int ir_raw_event_thread(void *data)
-{
-	DEFINE_REMOTE_RAW_EVENT(ev);
-	struct remote_raw_handler *handler;
-	struct remote_raw_handle *raw = (struct remote_raw_handle *)data;
-	int retval;
-
-	while (!kthread_should_stop()) {
-		/*spin_lock_irq(&raw->lock); */
-		retval = kfifo_len(&raw->kfifo);
-
-		if (retval < sizeof(ev)) {
-			set_current_state(TASK_INTERRUPTIBLE);
-
-			if (kthread_should_stop())
-				set_current_state(TASK_RUNNING);
-
-			/* spin_unlock_irq(&raw->lock); */
-			schedule();
-			continue;
-		}
-
-		retval = kfifo_out(&raw->kfifo, &ev, sizeof(ev));
-		/*spin_unlock_irq(&raw->lock); */
-
-		mutex_lock(&remote_raw_handler_lock);
-		list_for_each_entry(handler, &remote_raw_handler_list, list)
-			handler->decode(raw->dev, ev, handler->data);
-		mutex_unlock(&remote_raw_handler_lock);
-	}
-
-	return 0;
-}
-
-int remote_raw_event_store(struct remote_dev *dev,
-	struct remote_raw_event *ev)
-{
-	if (!dev->raw)
-		return -EINVAL;
-
-	if (kfifo_in(&dev->raw->kfifo, ev, sizeof(*ev)) != sizeof(*ev))
-		return -ENOMEM;
-
-	return 0;
-}
-
-int remote_raw_event_store_edge(struct remote_dev *dev,
-	enum raw_event_type type, u32 duration)
-{
-	DEFINE_REMOTE_RAW_EVENT(ev);
-	int rc = 0;
-	unsigned long timeout;
-
-	if (!dev->raw)
-		return -EINVAL;
-
-	timeout = dev->raw->jiffies_old +
-		msecs_to_jiffies(dev->raw->max_frame_time);
-
-	if (time_after(jiffies, timeout) || !dev->raw->last_type)
-		type |= RAW_START_EVENT;
-	else
-		ev.duration = duration;
-
-	if (type & RAW_START_EVENT)
-		ev.reset = true;
-	else if (dev->raw->last_type & RAW_SPACE)
-		ev.pulse = false;
-	else if (dev->raw->last_type & RAW_PULSE)
-		ev.pulse = true;
-	else
-		return 0;
-
-	rc = remote_raw_event_store(dev, &ev);
-
-	dev->raw->last_type = type;
-	dev->raw->jiffies_old = jiffies;
-	return rc;
-}
-
-
-void remote_raw_event_handle(struct remote_dev *dev)
-{
-/*	unsigned long flags;*/
-
-	if (!dev || !dev->raw)
-		return;
-
-/*	spin_lock_irqsave(&dev->raw->lock, flags);*/
-	wake_up_process(dev->raw->thread);
-/*	spin_unlock_irqrestore(&dev->raw->lock, flags);*/
-}
-
-int remote_raw_event_register(struct remote_dev *dev)
-{
-	int ret;
-
-	dev_info(dev->dev, "remote_raw_event_register\n");
-	dev->raw = kzalloc(sizeof(*dev->raw), GFP_KERNEL);
-	if (!dev->raw)
-		return -ENOMEM;
-
-	dev->raw->dev = dev;
-	dev->raw->max_frame_time = dev->max_frame_time;
-
-	dev->raw->jiffies_old = jiffies;
-
-	ret = kfifo_alloc(&dev->raw->kfifo,
-		 sizeof(struct remote_raw_event)*MAX_REMOTE_EVENT_SIZE,
-		 GFP_KERNEL);
-	if (ret < 0)
-		goto out;
-
-	dev->raw->thread = kthread_run(ir_raw_event_thread, dev->raw,
-		 "remote-thread");
-
-	if (IS_ERR(dev->raw->thread)) {
-		ret = PTR_ERR(dev->raw->thread);
-		goto err_alloc_thread;
-	}
-	mutex_lock(&remote_raw_handler_lock);
-	list_add_tail(&dev->raw->list, &remote_raw_client_list);
-	mutex_unlock(&remote_raw_handler_lock);
-	return 0;
-err_alloc_thread:
-	kfifo_free(&dev->raw->kfifo);
-out:
-	kfree(dev->raw);
-	return ret;
-}
-
-void remote_raw_event_unregister(struct remote_dev *dev)
-{
-	if (!dev || !dev->raw)
-		return;
-
-	kthread_stop(dev->raw->thread);
-	mutex_lock(&remote_raw_handler_lock);
-	list_del(&dev->raw->list);
-	mutex_unlock(&remote_raw_handler_lock);
-
-}
-
-int remote_raw_handler_register(struct remote_raw_handler *handler)
-{
-	mutex_lock(&remote_raw_handler_lock);
-	list_add_tail(&(handler->list), &remote_raw_handler_list);
-	mutex_unlock(&remote_raw_handler_lock);
-	return 0;
-}
-EXPORT_SYMBOL(remote_raw_handler_register);
-
-void remote_raw_handler_unregister(struct remote_raw_handler *handler)
-{
-	mutex_lock(&remote_raw_handler_lock);
-	list_del(&(handler->list));
-	mutex_unlock(&remote_raw_handler_lock);
-}
-EXPORT_SYMBOL(remote_raw_handler_unregister);
-
-
-void remote_raw_init(void)
-{
-	static bool raw_init;
-
-	if (!raw_init) {
-		raw_init = true;
-		pr_info("%s: loading raw decoder\n", DRIVER_NAME);
-
-		/* Load the decoder modules */
-		request_module_nowait("remote_decoder_xmp");
-	}
-}
-
-
-
diff --git a/drivers/amlogic/input/remote/remote_regmap.c b/drivers/amlogic/input/remote/remote_regmap.c
deleted file mode 100644
index ff75e171efa9..000000000000
--- a/drivers/amlogic/input/remote/remote_regmap.c
+++ /dev/null
@@ -1,716 +0,0 @@
-/*
- * drivers/amlogic/input/remote/remote_regmap.c
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#include "remote_meson.h"
-
-static struct remote_reg_map regs_legacy_nec[] = {
-	{REG_LDR_ACTIVE,    (500 << 16) | (400 << 0)},
-	{REG_LDR_IDLE,      300 << 16 | 200 << 0},
-	{REG_LDR_REPEAT,    150 << 16 | 80 << 0},
-	{REG_BIT_0,         72 << 16 | 40 << 0 },
-	{REG_REG0,          7 << 28 | (0xFA0 << 12) | 0x13},
-	{REG_STATUS,        (134 << 20) | (90 << 10)},
-	{REG_REG1,          0xbe00},
-};
-
-static struct remote_reg_map regs_default_nec[] = {
-	{ REG_LDR_ACTIVE,   (500 << 16) | (400 << 0)},
-	{ REG_LDR_IDLE,     300 << 16 | 200 << 0},
-	{ REG_LDR_REPEAT,   150 << 16 | 80 << 0},
-	{ REG_BIT_0,        72 << 16 | 40 << 0},
-	{ REG_REG0,         7 << 28 | (0xFA0 << 12) | 0x13},
-	{ REG_STATUS,       (134 << 20) | (90 << 10)},
-	{ REG_REG1,         0x9f00},
-	{ REG_REG2,         0x00},
-	{ REG_DURATN2,      0x00},
-	{ REG_DURATN3,      0x00}
-};
-
-static struct remote_reg_map regs_default_duokan[] = {
-	{ REG_LDR_ACTIVE,   ((70 << 16) | (30 << 0))},
-	{ REG_LDR_IDLE,     ((50 << 16) | (15 << 0))},
-	{ REG_LDR_REPEAT,   ((30 << 16) | (26 << 0))},
-	{ REG_BIT_0,        ((66 << 16) | (40 << 0))},
-	{ REG_REG0,         ((3 << 28) | (0x4e2 << 12) | (0x13))},
-	{ REG_STATUS,       ((80 << 20) | (66 << 10))},
-	{ REG_REG1,         0x9300},
-	{ REG_REG2,         0xb90b},
-	{ REG_DURATN2,      ((97 << 16) | (80 << 0))},
-	{ REG_DURATN3,      ((120 << 16) | (97 << 0))},
-	{ REG_REG3,         5000<<0}
-};
-
-static struct remote_reg_map regs_default_xmp_1_sw[] = {
-	{ REG_LDR_ACTIVE,   0},
-	{ REG_LDR_IDLE,     0},
-	{ REG_LDR_REPEAT,   0},
-	{ REG_BIT_0,        0},
-	{ REG_REG0,        ((3 << 28) | (0xFA0 << 12) | (9))},
-	{ REG_STATUS,       0},
-	{ REG_REG1,         0x8574},
-	{ REG_REG2,         0x02},
-	{ REG_DURATN2,      0},
-	{ REG_DURATN3,      0},
-	{ REG_REG3,         0}
-};
-
-static struct remote_reg_map regs_default_xmp_1[] = {
-	{ REG_LDR_ACTIVE,   0},
-	{ REG_LDR_IDLE,     0},
-	{ REG_LDR_REPEAT,   0},
-	{ REG_BIT_0,        (52 << 16) | (45<<0)},
-	{ REG_REG0,         ((7 << 28) | (0x5DC << 12) | (0x13))},
-	{ REG_STATUS,       (87 << 20) | (80 << 10)},
-	{ REG_REG1,         0x9f00},
-	{ REG_REG2,         0xa90e},
-	/*n=10,758+137*10=2128us,2128/20= 106*/
-	{ REG_DURATN2,      (121<<16) | (114<<0)},
-	{ REG_DURATN3,      (7<<16) | (7<<0)},
-	{ REG_REG3,         0}
-};
-
-static struct remote_reg_map regs_default_nec_sw[] = {
-	{ REG_LDR_ACTIVE,   0},
-	{ REG_LDR_IDLE,     0},
-	{ REG_LDR_REPEAT,   0},
-	{ REG_BIT_0,        0},
-	{ REG_REG0,        ((7 << 28) | (0xFA0 << 12) | (9))},
-	{ REG_STATUS,       0},
-	{ REG_REG1,         0x8574},
-	{ REG_REG2,         0x02},
-	{ REG_DURATN2,      0},
-	{ REG_DURATN3,      0},
-	{ REG_REG3,         0}
-};
-
-static struct remote_reg_map regs_default_rc5[] = {
-	{ REG_LDR_ACTIVE,   0},
-	{ REG_LDR_IDLE,     0},
-	{ REG_LDR_REPEAT,   0},
-	{ REG_BIT_0,        0},
-	{ REG_REG0,         ((3 << 28) | (0x1644 << 12) | 0x13)},
-	{ REG_STATUS,       (1 << 30)},
-	{ REG_REG1,         ((1 << 15) | (13 << 8))},
-	/*bit[0-3]: RC5; bit[8]: MSB first mode; bit[11]: compare frame method*/
-	{ REG_REG2,         ((1 << 13) | (1 << 11) | (1 << 8) | 0x7)},
-	/*Half bit for RC5 format: 888.89us*/
-	{ REG_DURATN2,      ((53 << 16) | (38 << 0))},
-	/*RC5 typically 1777.78us for whole bit*/
-	{ REG_DURATN3,      ((99 << 16) | (81 << 0))},
-	{ REG_REG3,         0}
-};
-
-static struct remote_reg_map regs_default_rc6[] = {
-	{REG_LDR_ACTIVE,    (210 << 16) | (125 << 0)},
-	/*rca leader 4000us,200* timebase*/
-	{REG_LDR_IDLE,      50 << 16 | 38 << 0}, /* leader idle 400*/
-	{REG_LDR_REPEAT,    145 << 16 | 125 << 0}, /* leader repeat*/
-	/* logic '0' or '00' 1500us*/
-	{REG_BIT_0,         51 << 16 | 38 << 0 },
-	{REG_REG0,          (7 << 28)|(0xFA0 << 12)|0x13},
-	/* sys clock boby time.base time = 20 body frame*/
-	{REG_STATUS,       (94 << 20) | (82 << 10)},
-	/*20bit:9440 32bit:9f40 36bit:a340 37bit:a440*/
-	{REG_REG1,         0xa440},
-	/*it may get the wrong customer value and key value from register if
-	 *the value is set to 0x4,so the register value must set to 0x104
-	 */
-	{REG_REG2,         0x2909},
-	{REG_DURATN2,      ((28 << 16) | (16 << 0))},
-	{REG_DURATN3,      ((51 << 16) | (38 << 0))},
-};
-
-static struct remote_reg_map regs_default_toshiba[] = {
-	{ REG_LDR_ACTIVE,	(280 << 16) | (180 << 0)},
-	{ REG_LDR_IDLE,		(280 << 16) | (180 << 0)},
-	{ REG_LDR_REPEAT,	(150 << 16) | (60 << 0)},
-	{ REG_BIT_0,		(72 << 16) | (40 << 0)},
-	{ REG_REG0,		(7 << 28) | (0xFA0 << 12) | 0x13},
-	{ REG_STATUS,		(134 << 20) | (90 << 10)},
-	{ REG_REG1,		0x9f00},
-	{ REG_REG2,		(0x05) | (1 << 24) | (23 << 11)},
-	{ REG_DURATN2,		0x00},
-	{ REG_DURATN3,		0x00},
-	{ REG_REPEAT_DET,	(1 << 31) | (0xFA0 << 16) | (10 << 0)},
-	{ REG_REG3,		0x2AF8},
-};
-
-static struct remote_reg_map regs_default_rca[] = {
-	{ REG_LDR_ACTIVE,   (250 << 16) | (160 << 0)},
-	{ REG_LDR_IDLE,     250 << 16 | 160 << 0},
-	{ REG_LDR_REPEAT,   250 << 16 | 160 << 0},
-	{ REG_BIT_0,        100 << 16 | 48 << 0},
-	{ REG_REG0,         7 << 28 | (0xFA0 << 12) | 0x13},
-	{ REG_STATUS,       (150 << 20) | (110 << 10)},
-	{ REG_REG1,         0x9700},
-	{ REG_REG2,         0x104 | (1 << 24) | (23 << 11)},
-	{ REG_DURATN2,      0x00},
-	{ REG_REPEAT_DET,  (1 << 31) | (0xFA0 << 16) | (10 << 0)},
-	{ REG_REG3,        0x1A00},
-	{ REG_DURATN3,      0x00}
-};
-
-static int ir_toshiba_get_scancode(struct remote_chip *chip)
-{
-	int  code = 0;
-	int decode_status = 0;
-	int status = 0;
-
-	remote_reg_read(chip, MULTI_IR_ID, REG_STATUS, &decode_status);
-	if (decode_status & 0x01)
-		status |= REMOTE_REPEAT;
-	chip->decode_status = status; /*set decode status*/
-	remote_reg_read(chip, MULTI_IR_ID, REG_FRAME, &code);
-	remote_dbg(chip->dev, "framecode=0x%x\n", code);
-	chip->r_dev->cur_hardcode = code;
-	code = (code >> 16) & 0xff;
-	return code;
-
-}
-
-static int ir_toshiba_get_decode_status(struct remote_chip *chip)
-{
-	int status = chip->decode_status;
-	return status;
-}
-
-static u32 ir_toshiba_get_custom_code(struct remote_chip *chip)
-{
-	u32 custom_code;
-
-	custom_code = (chip->r_dev->cur_hardcode) & 0xffff;
-	return custom_code;
-}
-
-void set_hardcode(struct remote_chip *chip, int code)
-{
-	remote_dbg(chip->dev, "framecode=0x%x\n", code);
-	chip->r_dev->cur_hardcode = code;
-}
-
-/**
- * legacy nec hardware interface
- * other interface share with the multi-format NEC
- */
-static int ir_legacy_nec_get_scancode(struct remote_chip *chip)
-{
-	int  code = 0;
-	int decode_status = 0;
-	int status = 0;
-
-	remote_reg_read(chip, LEGACY_IR_ID, REG_STATUS, &decode_status);
-	if (decode_status & 0x01)
-		status |= REMOTE_REPEAT;
-	chip->decode_status = status; /*set decode status*/
-	remote_reg_read(chip, LEGACY_IR_ID, REG_FRAME, &code);
-	remote_dbg(chip->dev, "framecode=0x%x\n", code);
-	chip->r_dev->cur_hardcode = code;
-	code = (code >> 16) & 0xff;
-	return code;
-}
-
-/*
- *nec hardware interface
- */
-static int ir_nec_get_scancode(struct remote_chip *chip)
-{
-	int  code = 0;
-	int decode_status = 0;
-	int status = 0;
-
-	remote_reg_read(chip, MULTI_IR_ID, REG_STATUS, &decode_status);
-	if (decode_status & 0x01)
-		status |= REMOTE_REPEAT;
-	chip->decode_status = status; /*set decode status*/
-	remote_reg_read(chip, MULTI_IR_ID, REG_FRAME, &code);
-	remote_dbg(chip->dev, "framecode=0x%x\n", code);
-	chip->r_dev->cur_hardcode = code;
-	code = (code >> 16) & 0xff;
-	return code;
-}
-
-static int ir_nec_get_decode_status(struct remote_chip *chip)
-{
-	int status = chip->decode_status;
-	return status;
-}
-
-static u32 ir_nec_get_custom_code(struct remote_chip *chip)
-{
-	u32 custom_code;
-
-	custom_code = chip->r_dev->cur_hardcode & 0xffff;
-	return custom_code;
-}
-
-/*
- *	xmp-1 decode hardware interface
- */
-static int xmp_decode_second;
-static int ir_xmp_get_scancode(struct remote_chip *chip)
-{
-	int  code = 0;
-
-	remote_reg_read(chip, MULTI_IR_ID, REG_FRAME, &code);
-	remote_dbg(chip->dev, "framecode=0x%x\n", code);
-	if (!xmp_decode_second) {
-		chip->r_dev->cur_hardcode = 0;
-		chip->r_dev->cur_customcode = code;
-		xmp_decode_second = 1;
-		return -1;
-	}
-	xmp_decode_second = 2;
-	chip->r_dev->cur_hardcode = code;
-	code = (code >> 8) & 0xff;
-	return code;
-}
-
-static int ir_xmp_get_decode_status(struct remote_chip *chip)
-{
-	int status = 0;
-
-	switch (xmp_decode_second) {
-	case 0:
-	case 1:
-		status = REMOTE_CUSTOM_DATA;
-		break;
-	case 2:
-		if (chip->r_dev->cur_hardcode & (8<<20))
-			status = REMOTE_REPEAT;
-		else
-			status = REMOTE_NORMAL;
-		xmp_decode_second = 0;
-		break;
-	default:
-		break;
-	}
-	return status;
-}
-
-static u32 ir_xmp_get_custom_code(struct remote_chip *chip)
-{
-	u32 custom_code;
-
-	custom_code = chip->r_dev->cur_customcode & 0xffff;
-	remote_dbg(chip->dev, "custom_code=0x%x\n", custom_code);
-	return custom_code;
-}
-
-/*
- * duokan hardware interface
- */
-static int duokan_parity_check(int code)
-{
-	unsigned int data;
-	unsigned int c74, c30, d74, d30, p30;
-
-	c74 = (code >> 16) & 0xF;
-	c30 = (code >> 12) & 0xF;
-	d74 = (code >> 8)  & 0xF;
-	d30 = (code >> 4)  & 0xF;
-	p30 = (code >> 0)  & 0xF;
-
-	data = c74 ^ c30 ^ d74 ^ d30;
-
-	if (p30 == data)
-		return 0;
-
-	pr_err("%s: parity check error code=0x%x\n", DRIVER_NAME, code);
-	return -1;
-}
-
-static int ir_duokan_get_scancode(struct remote_chip *chip)
-{
-	int  code = 0;
-
-	remote_reg_read(chip, MULTI_IR_ID, REG_FRAME, &code);
-	if (duokan_parity_check(code) < 0) {
-		set_hardcode(chip, 0);
-		return 0;
-	}
-	set_hardcode(chip, code);
-	code = (code >> 4) & 0xff;
-	return code;
-}
-
-
-static int ir_duokan_get_decode_status(struct remote_chip *chip)
-{
-	int decode_status = 0;
-	int status = 0;
-
-	remote_reg_read(chip, MULTI_IR_ID, REG_STATUS, &decode_status);
-	decode_status &= 0xf;
-	if (decode_status & 0x01)
-		status |= REMOTE_REPEAT;
-	/*
-	 *it is error,if the custom_code is not mask.
-	 *if (decode_status & 0x02)
-	 *	status |= REMOTE_CUSTOM_ERROR;
-	 */
-	if (decode_status & 0x04)
-		status |= REMOTE_DATA_ERROR;
-	return status;
-
-}
-
-
-static u32 ir_duokan_get_custom_code(struct remote_chip *chip)
-{
-	u32 custom_code;
-
-	custom_code = (chip->r_dev->cur_hardcode >> 12) & 0xffff;
-	chip->r_dev->cur_customcode = custom_code;
-	remote_dbg(chip->dev, "custom_code=0x%x\n", custom_code);
-	return custom_code;
-}
-
-/*
- *xmp-1 raw decoder interface
- */
-static u32 ir_raw_xmp_get_custom_code(struct remote_chip *chip)
-{
-	u32 custom_code;
-
-	custom_code = chip->r_dev->cur_customcode;
-	remote_dbg(chip->dev, "custom_code=0x%x\n", custom_code);
-	return custom_code;
-}
-
-static bool ir_raw_xmp_set_custom_code(struct remote_chip *chip, u32 code)
-{
-	chip->r_dev->cur_customcode = code;
-	return 0;
-}
-
-/*
- * RC5 decoder interface
- * 14bit of one frame is stored in [13:0]:
- *      bit[13:11] is S1, S2, Toggle
- *      bit[10:6] is system_code/custom_code
- *      bit [5:0] is data_code/scan_code
- */
-
-static int ir_rc5_get_scancode(struct remote_chip *chip)
-{
-	int code = 0;
-	int status = 0;
-	int decode_status = 0;
-
-	remote_reg_read(chip, MULTI_IR_ID, REG_STATUS, &decode_status);
-	decode_status &= 0xf;
-	if (decode_status & 0x01)
-		status |= REMOTE_REPEAT;
-	chip->decode_status = status;
-	remote_reg_read(chip, MULTI_IR_ID, REG_FRAME, &code);
-	remote_dbg(chip->dev, "framecode=0x%x\n", code);
-	chip->r_dev->cur_hardcode = code;
-	code = code & 0x3f;
-	return code;
-}
-
-static int ir_rc5_get_decode_status(struct remote_chip *chip)
-{
-	int status = chip->decode_status;
-
-	return status;
-}
-
-static u32 ir_rc5_get_custom_code(struct remote_chip *chip)
-{
-	u32 custom_code;
-
-	custom_code = (chip->r_dev->cur_hardcode >> 6) & 0x1f;
-	return custom_code;
-}
-
-/*RC6 decode interface*/
-static int ir_rc6_get_scancode(struct remote_chip *chip)
-{
-	int code = 0;
-	int code1 = 0;
-	int status = 0;
-	int decode_status = 0;
-
-	remote_reg_read(chip, MULTI_IR_ID, REG_STATUS, &decode_status);
-	decode_status &= 0xf;
-	if (decode_status & 0x01)
-		status |= REMOTE_REPEAT;
-	chip->decode_status = status;
-	remote_reg_read(chip, MULTI_IR_ID, REG_FRAME, &code);
-	remote_dbg(chip->dev, "framecode=0x%x\n", code);
-	/**
-	 *if the frame length larger than 32Bit, we must read the REG_FRAME1.
-	 *Otherwise it will affect the update of the 'frame1' and repeat frame
-	 *detect
-	 */
-	remote_reg_read(chip, MULTI_IR_ID, REG_FRAME1, &code1);
-	chip->r_dev->cur_hardcode = code;
-	code = code & 0xff;
-	return code;
-}
-
-static int ir_rc6_get_decode_status(struct remote_chip *chip)
-{
-	int status = chip->decode_status;
-
-	return status;
-}
-
-static u32 ir_rc6_get_custom_code(struct remote_chip *chip)
-{
-	u32 custom_code;
-
-	custom_code = (chip->r_dev->cur_hardcode >> 16) & 0xffff;
-	return custom_code;
-}
-
-static int ir_rca_get_scancode(struct remote_chip *chip)
-{
-	int  code = 0;
-	int decode_status = 0;
-	int status = 0;
-
-	remote_reg_read(chip, MULTI_IR_ID, REG_STATUS, &decode_status);
-	decode_status &= 0xf;
-	if (decode_status & 0x01)
-		status |= REMOTE_REPEAT;
-
-	chip->decode_status = status;
-	remote_reg_read(chip, MULTI_IR_ID, REG_FRAME, &code);
-	remote_dbg(chip->dev, "framecode=0x%x\n", code);
-	chip->r_dev->cur_hardcode = code;
-	code = (code >> 12) & 0xff;
-	return code;
-}
-
-static int ir_rca_get_decode_status(struct remote_chip *chip)
-{
-	int status = chip->decode_status;
-
-	return status;
-}
-
-static u32 ir_rca_get_custom_code(struct remote_chip *chip)
-{
-	u32 custom_code;
-
-	custom_code = (chip->r_dev->cur_hardcode >> 20) & 0x0f;
-	remote_dbg(chip->dev, "custom code=0x%x\n", custom_code);
-	return custom_code;
-}
-
-/*legacy IR controller support protocols*/
-static struct aml_remote_reg_proto reg_legacy_nec = {
-	.protocol = REMOTE_TYPE_LEGACY_NEC,
-	.name     = "LEGACY_NEC",
-	.reg_map      = regs_legacy_nec,
-	.reg_map_size = ARRAY_SIZE(regs_legacy_nec),
-	.get_scancode      = ir_legacy_nec_get_scancode,
-	.get_decode_status = ir_nec_get_decode_status,
-	.get_custom_code   = ir_nec_get_custom_code
-};
-
-static struct aml_remote_reg_proto reg_nec = {
-	.protocol = REMOTE_TYPE_NEC,
-	.name     = "NEC",
-	.reg_map      = regs_default_nec,
-	.reg_map_size = ARRAY_SIZE(regs_default_nec),
-	.get_scancode      = ir_nec_get_scancode,
-	.get_decode_status = ir_nec_get_decode_status,
-	.get_custom_code   = ir_nec_get_custom_code
-};
-
-static struct aml_remote_reg_proto reg_duokan = {
-	.protocol = REMOTE_TYPE_DUOKAN,
-	.name	  = "DUOKAN",
-	.reg_map      = regs_default_duokan,
-	.reg_map_size = ARRAY_SIZE(regs_default_duokan),
-	.get_scancode      = ir_duokan_get_scancode,
-	.get_decode_status = ir_duokan_get_decode_status,
-	.get_custom_code   = ir_duokan_get_custom_code
-};
-
-static struct aml_remote_reg_proto reg_xmp_1_sw = {
-	.protocol = REMOTE_TYPE_RAW_XMP_1,
-	.name	  = "XMP-1-RAW",
-	.reg_map      = regs_default_xmp_1_sw,
-	.reg_map_size = ARRAY_SIZE(regs_default_xmp_1_sw),
-	.get_scancode      = NULL,
-	.get_decode_status = NULL,
-	.get_custom_code   = ir_raw_xmp_get_custom_code,
-	.set_custom_code   = ir_raw_xmp_set_custom_code
-};
-
-static struct aml_remote_reg_proto reg_xmp_1 = {
-	.protocol = REMOTE_TYPE_XMP_1,
-	.name	  = "XMP-1",
-	.reg_map      = regs_default_xmp_1,
-	.reg_map_size = ARRAY_SIZE(regs_default_xmp_1),
-	.get_scancode      = ir_xmp_get_scancode,
-	.get_decode_status = ir_xmp_get_decode_status,
-	.get_custom_code   = ir_xmp_get_custom_code,
-};
-
-static struct aml_remote_reg_proto reg_nec_sw = {
-	.protocol = REMOTE_TYPE_RAW_NEC,
-	.name	  = "NEC-SW",
-	.reg_map      = regs_default_nec_sw,
-	.reg_map_size = ARRAY_SIZE(regs_default_nec_sw),
-	.get_scancode      = NULL,
-	.get_decode_status = NULL,
-	.get_custom_code   = NULL,
-};
-
-static struct aml_remote_reg_proto reg_rc5 = {
-	.protocol = REMOTE_TYPE_RC5,
-	.name	  = "RC5",
-	.reg_map      = regs_default_rc5,
-	.reg_map_size = ARRAY_SIZE(regs_default_rc5),
-	.get_scancode      = ir_rc5_get_scancode,
-	.get_decode_status = ir_rc5_get_decode_status,
-	.get_custom_code   = ir_rc5_get_custom_code,
-};
-
-static struct aml_remote_reg_proto reg_rc6 = {
-	.protocol = REMOTE_TYPE_RC6,
-	.name	  = "RC6",
-	.reg_map      = regs_default_rc6,
-	.reg_map_size = ARRAY_SIZE(regs_default_rc6),
-	.get_scancode      = ir_rc6_get_scancode,
-	.get_decode_status = ir_rc6_get_decode_status,
-	.get_custom_code   = ir_rc6_get_custom_code,
-};
-
-static struct aml_remote_reg_proto reg_toshiba = {
-	.protocol = REMOTE_TYPE_TOSHIBA,
-	.name     = "TOSHIBA",
-	.reg_map      = regs_default_toshiba,
-	.reg_map_size = ARRAY_SIZE(regs_default_toshiba),
-	.get_scancode      = ir_toshiba_get_scancode,
-	.get_decode_status = ir_toshiba_get_decode_status,
-	.get_custom_code   = ir_toshiba_get_custom_code,
-};
-
-static struct aml_remote_reg_proto reg_rca = {
-	.protocol = REMOTE_TYPE_RCA,
-	.name	  = "rca",
-	.reg_map      = regs_default_rca,
-	.reg_map_size = ARRAY_SIZE(regs_default_rca),
-	.get_scancode	   = ir_rca_get_scancode,
-	.get_decode_status = ir_rca_get_decode_status,
-	.get_custom_code   = ir_rca_get_custom_code,
-};
-
-const struct aml_remote_reg_proto *remote_reg_proto[] = {
-	&reg_nec,
-	&reg_duokan,
-	&reg_xmp_1,
-	&reg_xmp_1_sw,
-	&reg_nec_sw,
-	&reg_rc5,
-	&reg_rc6,
-	&reg_legacy_nec,
-	&reg_toshiba,
-	&reg_rca,
-	NULL
-};
-
-const struct aml_remote_reg_proto **ir_get_proto_reg(void)
-{
-	return remote_reg_proto;
-}
-
-static int ir_contr_init(struct remote_chip *chip, int type, unsigned char id)
-{
-	const struct aml_remote_reg_proto **reg_proto = remote_reg_proto;
-	struct remote_reg_map *reg_map;
-	int size;
-	int status;
-
-	for ( ; (*reg_proto) != NULL ; ) {
-		if ((*reg_proto)->protocol == type)
-			break;
-		reg_proto++;
-	}
-	if (!*reg_proto) {
-		dev_err(chip->dev, "%s, protocol set err %d\n", __func__, type);
-		return -EINVAL;
-	}
-
-	remote_reg_read(chip, id, REG_STATUS, &status);
-	remote_reg_read(chip, id, REG_FRAME,  &status);
-	/*
-	 * reset ir decoder and disable the state machine
-	 * of IR decoder.
-	 * [15] = 0 ,disable the machine of IR decoder
-	 * [0] = 0x01,set to 1 to reset the IR decoder
-	 */
-	remote_reg_write(chip, id, REG_REG1, 0x01);
-	dev_info(chip->dev, "default protocol = 0x%x and id = %d\n",
-				(*reg_proto)->protocol, id);
-	reg_map = (*reg_proto)->reg_map;
-	size    = (*reg_proto)->reg_map_size;
-
-	for (  ; size > 0;  ) {
-		remote_reg_write(chip, id, reg_map->reg, reg_map->val);
-		dev_info(chip->dev, "reg=0x%x, val=0x%x\n",
-				reg_map->reg, reg_map->val);
-		reg_map++;
-		size--;
-	}
-	/*
-	 * when we reinstall remote controller register,
-	 * we need reset IR decoder, set 1 to REG_REG1 bit0,
-	 * after IR decoder reset, we need to clear the bit0
-	 */
-	remote_reg_read(chip, id, REG_REG1, &status);
-	status |= 1;
-	remote_reg_write(chip, id, REG_REG1, status);
-	status &= ~0x01;
-	remote_reg_write(chip, id, REG_REG1, status);
-	chip->ir_contr[id].get_scancode      = (*reg_proto)->get_scancode;
-	chip->ir_contr[id].get_decode_status = (*reg_proto)->get_decode_status;
-	chip->ir_contr[id].proto_name        = (*reg_proto)->name;
-	chip->ir_contr[id].get_custom_code   = (*reg_proto)->get_custom_code;
-	chip->ir_contr[id].set_custom_code   = (*reg_proto)->set_custom_code;
-
-	if (chip->r_dev->ir_learning_on && chip->r_dev->use_fifo)
-		remote_reg_write(chip, id, REG_FIFO, FIFO_REG_VAL);
-	else
-		remote_reg_write(chip, id, REG_FIFO, 0);
-
-	return 0;
-}
-
-int ir_register_default_config(struct remote_chip *chip, int type)
-{
-	if (ENABLE_LEGACY_IR(type)) {
-		/*initialize registers for legacy IR controller*/
-		ir_contr_init(chip, LEGACY_IR_TYPE_MASK(type), LEGACY_IR_ID);
-	} else {
-		/*disable legacy IR controller: REG_REG1[15]*/
-		remote_reg_write(chip, LEGACY_IR_ID, REG_REG1, 0x0);
-	}
-	/*initialize registers for Multi-format IR controller*/
-	ir_contr_init(chip, MULTI_IR_TYPE_MASK(type), MULTI_IR_ID);
-
-	return 0;
-
-}
-EXPORT_SYMBOL(ir_register_default_config);
-
diff --git a/drivers/amlogic/input/remote/sysfs.c b/drivers/amlogic/input/remote/sysfs.c
deleted file mode 100644
index d0efa3d4de8e..000000000000
--- a/drivers/amlogic/input/remote/sysfs.c
+++ /dev/null
@@ -1,546 +0,0 @@
-/*
- * drivers/amlogic/input/remote/sysfs.c
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/types.h>
-#include <linux/input.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/errno.h>
-#include <asm/irq.h>
-#include <linux/io.h>
-#include <linux/major.h>
-#include <linux/slab.h>
-#include <linux/uaccess.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/of_platform.h>
-#include <linux/amlogic/cpu_version.h>
-#include <linux/of_address.h>
-
-#include "remote_meson.h"
-#include <linux/amlogic/iomap.h>
-
-static ssize_t protocol_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	const struct aml_remote_reg_proto **supported_proto =
-							ir_get_proto_reg();
-	int len;
-
-	if (ENABLE_LEGACY_IR(chip->protocol))
-		len =  sprintf(buf, "current protocol = %s&%s (0x%x)\n",
-			chip->ir_contr[LEGACY_IR_ID].proto_name,
-			chip->ir_contr[MULTI_IR_ID].proto_name,
-			chip->protocol);
-	else
-		len =  sprintf(buf, "currnet protocol = %s (0x%x)\n",
-			       chip->ir_contr[MULTI_IR_ID].proto_name,
-			       chip->protocol);
-
-	len += sprintf(buf + len, "supported protocol:\n");
-
-	for ( ; (*supported_proto) != NULL ; ) {
-		len += sprintf(buf + len, "%s (0x%x)\n",
-		((*supported_proto)->name), ((*supported_proto)->protocol));
-		supported_proto++;
-	}
-
-	return len;
-}
-
-static ssize_t protocol_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	int ret;
-	int protocol;
-	unsigned long flags;
-	struct remote_chip *chip = dev_get_drvdata(dev);
-
-	ret = kstrtoint(buf, 0, &protocol);
-	if (ret != 0) {
-		dev_err(chip->dev, "input parameter error\n");
-		return -EINVAL;
-	}
-
-	spin_lock_irqsave(&chip->slock, flags);
-	chip->protocol = protocol;
-	chip->set_register_config(chip, chip->protocol);
-	if (MULTI_IR_SOFTWARE_DECODE(chip->r_dev->rc_type) &&
-				!MULTI_IR_SOFTWARE_DECODE(chip->protocol)) {
-		remote_raw_event_unregister(chip->r_dev); /*raw->no raw*/
-		dev_info(chip->dev, "remote_raw_event_unregister\n");
-	} else if (!MULTI_IR_SOFTWARE_DECODE(chip->r_dev->rc_type) &&
-				MULTI_IR_SOFTWARE_DECODE(chip->protocol)) {
-		remote_raw_init();
-		remote_raw_event_register(chip->r_dev); /*no raw->raw*/
-	}
-	chip->r_dev->rc_type = chip->protocol;
-	spin_unlock_irqrestore(&chip->slock, flags);
-	return count;
-}
-
-static ssize_t keymap_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	struct ir_map_tab_list *map_tab;
-	unsigned long flags;
-	int i, len;
-
-	spin_lock_irqsave(&chip->slock, flags);
-	map_tab = seek_map_tab(chip, chip->sys_custom_code);
-	if (!map_tab) {
-		dev_err(chip->dev, "please set valid keymap name first\n");
-		spin_unlock_irqrestore(&chip->slock, flags);
-		return 0;
-	}
-	len = sprintf(buf, "custom_code=0x%x\n", map_tab->tab.custom_code);
-	len += sprintf(buf+len, "custom_name=%s\n",  map_tab->tab.custom_name);
-	len += sprintf(buf+len, "release_delay=%d\n",
-						map_tab->tab.release_delay);
-	len += sprintf(buf+len, "map_size=%d\n",  map_tab->tab.map_size);
-	len += sprintf(buf+len, "fn_key_scancode = 0x%x\n",
-				map_tab->tab.cursor_code.fn_key_scancode);
-	len += sprintf(buf+len, "cursor_left_scancode = 0x%x\n",
-				map_tab->tab.cursor_code.cursor_left_scancode);
-	len += sprintf(buf+len, "cursor_right_scancode = 0x%x\n",
-				map_tab->tab.cursor_code.cursor_right_scancode);
-	len += sprintf(buf+len, "cursor_up_scancode = 0x%x\n",
-				map_tab->tab.cursor_code.cursor_up_scancode);
-	len += sprintf(buf+len, "cursor_down_scancode = 0x%x\n",
-				map_tab->tab.cursor_code.cursor_down_scancode);
-	len += sprintf(buf+len, "cursor_ok_scancode = 0x%x\n",
-				map_tab->tab.cursor_code.cursor_ok_scancode);
-	len += sprintf(buf+len, "keycode scancode\n");
-	for (i = 0; i <  map_tab->tab.map_size; i++) {
-		len += sprintf(buf+len, "%4d %4d\n",
-			map_tab->tab.codemap[i].map.keycode,
-			map_tab->tab.codemap[i].map.scancode);
-	}
-	spin_unlock_irqrestore(&chip->slock, flags);
-	return len;
-}
-
-static ssize_t keymap_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	int ret;
-	int value;
-
-	ret = kstrtoint(buf, 0, &value);
-	if (ret != 0) {
-		dev_err(chip->dev, "keymap_store input err\n");
-		return -EINVAL;
-	}
-	chip->sys_custom_code = value;
-	return count;
-}
-
-static ssize_t debug_enable_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	int debug_enable;
-
-	debug_enable = remote_debug_get_enable();
-
-	return sprintf(buf, "%d\n", debug_enable);
-}
-
-static ssize_t debug_enable_store(struct device *dev,
-				   struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	int debug_enable;
-	int ret;
-
-	ret = kstrtoint(buf, 0, &debug_enable);
-	if (ret != 0)
-		return -EINVAL;
-	remote_debug_set_enable(debug_enable);
-	return count;
-}
-
-int debug_log_printk(struct remote_dev *dev, const char *fmt)
-{
-	char *p;
-	int len;
-
-	len = strlen(fmt) + 1;
-	if (len > dev->debug_buffer_size)
-		return 0;
-	if (dev->debug_current + len > dev->debug_buffer_size)
-		dev->debug_current = 0;
-	p = (char *)(dev->debug_buffer+dev->debug_current);
-	strcpy(p, fmt);
-	dev->debug_current += (len-1);
-	return 0;
-}
-EXPORT_SYMBOL(debug_log_printk);
-
-static ssize_t debug_log_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	struct remote_dev  *r_dev = chip->r_dev;
-
-	if (!r_dev->debug_buffer)
-		return 0;
-	return sprintf(buf, r_dev->debug_buffer);
-}
-
-static ssize_t debug_log_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	struct remote_dev  *r_dev = chip->r_dev;
-
-	if (!r_dev->debug_buffer)
-		return 0;
-	if (buf[0] == 'c') {
-		r_dev->debug_buffer[0] = 0;
-		r_dev->debug_current = 0;
-	}
-	return count;
-}
-
-static ssize_t repeat_enable_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct remote_chip *chip = dev_get_drvdata(dev);
-
-	return sprintf(buf, "%u\n", chip->repeat_enable);
-}
-
-static ssize_t repeat_enable_store(struct device *dev,
-				   struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	int ret;
-	int val;
-	struct remote_chip *chip = dev_get_drvdata(dev);
-
-	ret = kstrtoint(buf, 0, &val);
-	if (ret != 0)
-		return -EINVAL;
-	chip->repeat_enable = val;
-	return count;
-}
-
-static ssize_t map_tables_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	struct ir_map_tab_list *ir_map;
-	unsigned long flags;
-	int len = 0;
-	int cnt = 0;
-
-	spin_lock_irqsave(&chip->slock, flags);
-	list_for_each_entry(ir_map, &chip->map_tab_head, list) {
-		len += sprintf(buf+len, "%d. 0x%x,%s\n",
-			cnt, ir_map->tab.custom_code, ir_map->tab.custom_name);
-		cnt++;
-	}
-	spin_unlock_irqrestore(&chip->slock, flags);
-	return len;
-}
-
-static ssize_t led_blink_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	struct remote_dev  *r_dev = chip->r_dev;
-
-	return sprintf(buf, "%u\n", r_dev->led_blink);
-}
-
-static ssize_t led_blink_store(struct device *dev,
-				   struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	int ret = 0;
-	int val = 0;
-
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	struct remote_dev  *r_dev = chip->r_dev;
-
-	ret = kstrtoint(buf, 0, &val);
-	if (ret != 0)
-		return -EINVAL;
-	r_dev->led_blink = val;
-	return count;
-}
-
-static ssize_t led_frq_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	struct remote_dev  *r_dev = chip->r_dev;
-
-	return sprintf(buf, "%ld\n", r_dev->delay_on);
-}
-
-static ssize_t led_frq_store(struct device *dev,
-				   struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	int ret = 0;
-	int val = 0;
-
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	struct remote_dev  *r_dev = chip->r_dev;
-
-	ret = kstrtoint(buf, 0, &val);
-	if (ret != 0)
-		return -EINVAL;
-	r_dev->delay_off = val;
-	r_dev->delay_on = val;
-	return count;
-}
-
-static ssize_t ir_learning_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	struct remote_dev  *r_dev = chip->r_dev;
-
-	return sprintf(buf, "%d\n", r_dev->ir_learning_on);
-}
-
-static ssize_t ir_learning_store(struct device *dev,
-				 struct device_attribute *attr,
-				 const char *buf, size_t count)
-{
-	int ret = 0;
-	int val = 0;
-
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	struct remote_dev  *r_dev = chip->r_dev;
-
-	ret = kstrtoint(buf, 0, &val);
-	if (ret != 0)
-		return -EINVAL;
-	if (r_dev->ir_learning_on == val)
-		return count;
-
-	disable_irq(chip->irqno);
-	mutex_lock(&chip->file_lock);
-	r_dev->ir_learning_on = !!val;
-	if (!!val) {
-		if (r_dev->demod_enable)
-			demod_reset(chip);
-
-		if (remote_pulses_malloc(chip) < 0) {
-			mutex_unlock(&chip->file_lock);
-			enable_irq(chip->irqno);
-			return -ENOMEM;
-		}
-		chip->set_register_config(chip, REMOTE_TYPE_RAW_NEC);
-		r_dev->protocol = chip->protocol;/*backup protocol*/
-		chip->protocol = REMOTE_TYPE_RAW_NEC;
-		irq_set_affinity_hint(chip->irqno,
-				 cpumask_of(chip->irq_cpumask));
-	} else {
-		chip->protocol = r_dev->protocol;
-		chip->set_register_config(chip, chip->protocol);
-		remote_pulses_free(chip);
-		chip->r_dev->ir_learning_done = false;
-	}
-	mutex_unlock(&chip->file_lock);
-	enable_irq(chip->irqno);
-	return count;
-}
-
-static ssize_t learned_pulse_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	int len = 0;
-	int i = 0;
-
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	struct remote_dev  *r_dev = chip->r_dev;
-
-	if (!r_dev->pulses)
-		return len;
-
-	disable_irq(chip->irqno);
-	mutex_lock(&chip->file_lock);
-	for (i = 0; i < r_dev->pulses->len; i++)
-		len += sprintf(buf + len, "%lds",
-			       r_dev->pulses->pulse[i] & GENMASK(30, 0));
-
-	len += sprintf(buf + len, "\n");
-
-	remote_reg_update_bits(chip, MULTI_IR_ID, REG_REG1, BIT(15), BIT(15));
-
-	r_dev->ir_learning_done = false;
-
-	mutex_unlock(&chip->file_lock);
-	enable_irq(chip->irqno);
-
-	return len;
-}
-
-static ssize_t learned_pulse_store(struct device *dev,
-				   struct device_attribute *attr,
-				   const char *buf, size_t count)
-{
-	struct remote_chip *chip = dev_get_drvdata(dev);
-	struct remote_dev  *r_dev = chip->r_dev;
-
-	if (!r_dev->pulses)
-		return count;
-
-	disable_irq(chip->irqno);
-	mutex_lock(&chip->file_lock);
-	if (buf[0] == 'c') {
-		memset(r_dev->pulses, 0, sizeof(struct pulse_group) +
-		       r_dev->max_learned_pulse * sizeof(u32));
-		remote_reg_update_bits(chip, MULTI_IR_ID, REG_REG1, BIT(15),
-				       BIT(15));
-
-		r_dev->ir_learning_done = false;
-	}
-	mutex_unlock(&chip->file_lock);
-	enable_irq(chip->irqno);
-	return count;
-}
-
-static ssize_t sum_cnt0_show(struct device *dev,
-			     struct device_attribute *attr, char *buf)
-{
-	int val = 0;
-	struct remote_chip *chip = dev_get_drvdata(dev);
-
-	remote_reg_read(chip, MULTI_IR_ID, REG_DEMOD_SUM_CNT0, &val);
-
-	return sprintf(buf, "%d\n", val);
-}
-
-static ssize_t sum_cnt1_show(struct device *dev,
-			     struct device_attribute *attr, char *buf)
-{
-
-	int val = 0;
-	struct remote_chip *chip = dev_get_drvdata(dev);
-
-	remote_reg_read(chip, MULTI_IR_ID, REG_DEMOD_SUM_CNT1, &val);
-
-	return sprintf(buf, "%d\n", val);
-
-}
-
-static ssize_t use_fifo_show(struct device *dev,
-			     struct device_attribute *attr, char *buf)
-{
-	struct remote_chip *chip = dev_get_drvdata(dev);
-
-	return sprintf(buf, "%d\n", chip->r_dev->use_fifo);
-}
-
-static ssize_t use_fifo_store(struct device *dev, struct device_attribute *attr,
-			     const char *buf, size_t count)
-{
-	int val = 0;
-	int len = 0;
-	struct remote_chip *chip = dev_get_drvdata(dev);
-
-	len = kstrtoint(buf, 0, &val);
-
-	if (len != 0) {
-		dev_err(chip->dev, "input parameter error\n");
-		return -EINVAL;
-	}
-
-	chip->r_dev->use_fifo = val;
-
-	return count;
-}
-
-DEVICE_ATTR_RW(use_fifo);
-DEVICE_ATTR_RO(sum_cnt0);
-DEVICE_ATTR_RO(sum_cnt1);
-DEVICE_ATTR_RW(learned_pulse);
-DEVICE_ATTR_RW(ir_learning);
-DEVICE_ATTR_RW(led_frq);
-DEVICE_ATTR_RW(led_blink);
-DEVICE_ATTR_RW(repeat_enable);
-DEVICE_ATTR_RW(protocol);
-DEVICE_ATTR_RW(keymap);
-DEVICE_ATTR_RW(debug_enable);
-DEVICE_ATTR_RW(debug_log);
-DEVICE_ATTR_RO(map_tables);
-
-static struct attribute *remote_attrs[] = {
-	&dev_attr_protocol.attr,
-	&dev_attr_map_tables.attr,
-	&dev_attr_keymap.attr,
-	&dev_attr_debug_enable.attr,
-	&dev_attr_repeat_enable.attr,
-	&dev_attr_debug_log.attr,
-	&dev_attr_led_blink.attr,
-	&dev_attr_led_frq.attr,
-	&dev_attr_ir_learning.attr,
-	&dev_attr_learned_pulse.attr,
-	&dev_attr_sum_cnt0.attr,
-	&dev_attr_sum_cnt1.attr,
-	&dev_attr_use_fifo.attr,
-	NULL,
-};
-
-ATTRIBUTE_GROUPS(remote);
-
-static struct class remote_class = {
-	.name		= "remote",
-	.owner		= THIS_MODULE,
-	.dev_groups = remote_groups,
-};
-
-int ir_sys_device_attribute_init(struct remote_chip *chip)
-{
-	struct device *dev;
-	int err;
-
-	err = class_register(&remote_class);
-	if (unlikely(err))
-		return err;
-
-	dev = device_create(&remote_class,  NULL,
-					chip->chr_devno, chip, chip->dev_name);
-	if (IS_ERR_OR_NULL(dev))
-		return -1;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ir_sys_device_attribute_init);
-
-void ir_sys_device_attribute_sys(struct remote_chip *chip)
-{
-	device_destroy(&remote_class, chip->chr_devno);
-	class_unregister(&remote_class);
-}
-EXPORT_SYMBOL_GPL(ir_sys_device_attribute_sys);
diff --git a/drivers/amlogic/input/remote/sysfs.h b/drivers/amlogic/input/remote/sysfs.h
deleted file mode 100644
index 0ef8282c1ab6..000000000000
--- a/drivers/amlogic/input/remote/sysfs.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * drivers/amlogic/input/remote/sysfs.h
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#ifndef __REMOTE_SYSFS_H__
-#define __REMOTE_SYSFS_H__
-
-int ir_sys_device_attribute_init(struct remote_chip *rc);
-void ir_sys_device_attribute_sys(struct remote_chip *chip);
-
-
-
-#endif
-
-
-- 
2.17.1

